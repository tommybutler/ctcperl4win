.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "YAML::XS 3pm"
.TH YAML::XS 3pm "2018-01-01" "perl v5.22.5" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
YAML::XS \- Perl YAML Serialization using XS and libyaml
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use YAML::XS;
\&
\&    my $yaml = Dump [ 1..4 ];
\&    my $array = Load $yaml;
\&
\&    my $yaml = DumpFile ("my.yml", [ 1..4 ]);
\&    my $array = LoadFile "my.yml";
\&
\&    { # security, disable custom tags
\&      local $YAML::XS::DisableBlessed = 1;
\&      my $array = LoadFile("META.yml");
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Kirill Siminov's \f(CW\*(C`libyaml\*(C'\fR is a good \s-1YAML\s0 library implementation. The C
library is written precisely to the \s-1YAML 1.1\s0 specification, and offers \s-1YAML
1.2\s0 support. It was originally bound to Python and was later bound to Ruby.
\&\f(CW\*(C`libsyck\*(C'\fR is written a bit more elegant, has less bugs, is not as strict as
libyaml, but misses some \s-1YAML\s0 features. It can only do \s-1YAML 1.1\s0
.PP
This module is a Perl \s-1XS\s0 binding to libyaml which offers Perl somewhat
acceptable \s-1YAML\s0 support to date.
.PP
This module exports the functions \f(CW\*(C`Dump\*(C'\fR, \f(CW\*(C`Load\*(C'\fR, \f(CW\*(C`DumpFile\*(C'\fR and
\&\f(CW\*(C`LoadFile\*(C'\fR. These functions are intended to work exactly like \f(CW\*(C`YAML.pm\*(C'\fR's
corresponding functions.
.PP
If you set the option \f(CW$YAML::XS::IndentlessMap\fR to 0 or undef, \f(CW\*(C`YAML::XS\*(C'\fR
will behave like with version < 0.70, which creates yml files which cannot
be read by \f(CW\*(C`YAML.pm\*(C'\fR.
.PP
However the loader is stricter than \f(CW\*(C`YAML\*(C'\fR, \f(CW\*(C`YAML::Syck\*(C'\fR and
\&\f(CW\*(C`CPAN::Meta::YAML\*(C'\fR i.e. \f(CW\*(C`YAML::Tiny\*(C'\fR as used in core. Set the variable
\&\f(CW$YAML::XS::NonStrict\fR to allow certain reader errors to pass the
\&\f(CW\*(C`CPAN::Meta\*(C'\fR validation testsuite.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
.SS "Loader Options"
.IX Subsection "Loader Options"
via globals variables only, so far. Affecting Load and LoadFile.
.IP "\(bu" 4
\&\f(CW$YAML::XS::NonStrict\fR
.PP
Permit certain reader errors to loosely match other \s-1YAML\s0 module semantics. In
detail: Allow \f(CW"control characters are not allowed"\fR. Note that any error is
stored and returned, just not immediately.
.PP
However the reader error \f(CW"invalid trailing UTF\-8 octet"\fR and all other utf8
strictness violations are still fatal.
.PP
And if the structure of the \s-1YAML\s0 document cannot be parsed, i.e. a required
value consists only of invalid control characters, the loader returns an
error, unlike with non-strict \s-1YAML\s0 modules.
.IP "\(bu" 4
\&\f(CW$YAML::XS::DisableCode\fR
.PP
Not yet implemented. Disables support for deparsing and evaling of code blocks
while loading.
.IP "\(bu" 4
\&\f(CW$YAML::XS::DisableBlessed\fR
.PP
Disables support for blessing custom tags while loading, but allows pure perl
tags, such as array, hash and scalar.
.SS "Dumper Options"
.IX Subsection "Dumper Options"
via globals variables only, so far. Affecting Dump and DumpFile
.IP "\(bu" 4
\&\f(CW$YAML::XS::UseCode\fR
.PP
If enabled supports Dump of \s-1CV\s0 code blocks via \f(CW\*(C`YAML::XS::coderef2text()\*(C'\fR.
.IP "\(bu" 4
\&\f(CW$YAML::XS::DumpCode\fR
.PP
If enabled supports Dump of \s-1CV\s0 code blocks via \f(CW\*(C`YAML::XS::coderef2text()\*(C'\fR.
.IP "\(bu" 4
\&\f(CW$YAML::XS::QuoteNumericStrings\fR
.PP
When true (the default) strings that look like numbers but have not been
numified will be quoted when dumping.
.PP
This ensures leading that things like leading zeros and other formatting are
preserved.
.IP "\(bu" 4
\&\f(CW$YAML::XS::IndentlessMap\fR
.PP
Default 0
.PP
Set to 1 or a true value to fallback to the old \f(CW\*(C`YAML::XS\*(C'\fR behavior to omit
the indentation of map keys, which arguably violates the \s-1YAML\s0 spec, is
different to all other \s-1YAML\s0 libraries and causes \f(CW\*(C`YAML.pm\*(C'\fR to fail.
.PP
With 0
.PP
.Vb 2
\&     authors:
\&       \- this author
.Ve
.PP
With 1
.PP
.Vb 2
\&     authors:
\&     \- this author
.Ve
.IP "\(bu" 4
\&\f(CW$YAML::XS::Indent\fR
.PP
Default 2
.IP "\(bu" 4
\&\f(CW$YAML::XS::BestWidth\fR
.PP
Default 80
.PP
Control text wrapping.
.IP "\(bu" 4
\&\f(CW$YAML::XS::Canonical\fR
.PP
Default 1
.PP
Set to undef or 0 to disable sorting map keys.
.IP "\(bu" 4
\&\f(CW$YAML::XS::Unicode\fR
.PP
Default 1
.PP
Set to undef or 0 to disallow unescaped non-ASCII characters.
.IP "\(bu" 4
\&\f(CW$YAML::XS::Encoding\fR
.PP
Default utf8
.PP
Set to any, utf8, utf16le or utf16be
.IP "\(bu" 4
\&\f(CW$YAML::XS::LineBreak\fR
.PP
Default ln
.PP
Set to any, cr, ln or crln.
.IP "\(bu" 4
\&\f(CW$YAML::XS::OpenEnded\fR
.PP
Default 0
.PP
Set to 1 or a true value to embed the yaml into \*(L"...\*(R". If an explicit document
end is required.
.SH "USING YAML::XS WITH UNICODE"
.IX Header "USING YAML::XS WITH UNICODE"
Handling unicode properly in Perl can be a pain. \s-1YAML::XS\s0 only deals with
streams of utf8 octets. Just remember this:
.PP
.Vb 2
\&    $perl = Load($utf8_octets);
\&    $utf8_octets = Dump($perl);
.Ve
.PP
There are many, many places where things can go wrong with unicode. If you are
having problems, use Devel::Peek on all the possible data points.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
\&\s-1YAML\s0.pm
.IP "\(bu" 4
YAML::Syck
.IP "\(bu" 4
YAML::Tiny
.IP "\(bu" 4
CPAN::Meta::YAML
.SH "AUTHOR"
.IX Header "AUTHOR"
Ingy do\*:t Net <ingy@cpan.org>
.PP
Reini Urban <rurban@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2007\-2016. Ingy do\*:t Net.
.PP
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
.PP
See <http://www.perl.com/perl/misc/Artistic.html>
