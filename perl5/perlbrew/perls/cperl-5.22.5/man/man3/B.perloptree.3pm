.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::perloptree 3pm"
.TH B::perloptree 3pm "2018-01-01" "perl v5.22.5" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perloptree \- The Perl op tree
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Various material about the internal Perl compilation representation
during parsing and optimization, before the actual execution
begins, represented as \f(CW\*(C`B\*(C'\fR objects, the \fB\*(L"B\*(R" op tree\fR.
.PP
The well-known perlguts.pod focuses more on the internal
representation of the variables, but not so on the structure, the
sequence and the optimization of the basic operations, the ops.
.PP
illguts.pod, the \*(L"illustrated guts\*(R", explains the main data structures
in an easier to understand way than perlguts.
.PP
And we have perlhack.pod, which shows e.g. ways to hack into
the op tree structure within the debugger. It focuses on getting
people to start patching and hacking on the \s-1CORE,\s0 not
understanding or writing compiler backends or optimizations,
which the op tree mainly is used for.
.SH "Brief Summary"
.IX Header "Brief Summary"
The brief summary is very well described in the
\&\*(L"perlguts#Compiled\-code\*(R" in \*(L"Compiled-code\*(R" section of perlguts and 
at the top of \fIop.c\fR.
.PP
When Perl parses the source code (via Yacc \f(CW\*(C`perly.y\*(C'\fR), the so-called
op tree, a tree of basic perl \s-1OP\s0 structs pointing to simple
\&\f(CW\*(C`pp_\*(C'\fR\fIopname\fR functions, is generated bottom-up.  Those \f(CW\*(C`pp_\*(C'\fR
functions \- \*(L"\s-1PP\s0 Code\*(R" (for \*(L"Push / Pop Code\*(R") \- have the same uniform
\&\s-1API\s0 as the \s-1XS\s0 functions, all arguments and return values are
transported on the stack.  For example, an \f(CW\*(C`OP_CONST\*(C'\fR op points to
the \f(CW\*(C`pp_const()\*(C'\fR function and to an \f(CW\*(C`SV\*(C'\fR containing the constant
value. When \f(CW\*(C`pp_const()\*(C'\fR is executed, its job is to push that \f(CW\*(C`SV\*(C'\fR
onto the stack.
.PP
OPs are created by the \f(CW\*(C`newFOO()\*(C'\fR functions, which are called
from the parser (in \fIperly.y\fR) as the code is parsed. For
example the Perl code \f(CW\*(C`$a + $b * $c\*(C'\fR would cause the equivalent
of the following to be called (oversimplifying a bit):
.PP
.Vb 4
\&  newBINOP(OP_ADD, flags,
\&     newSVREF($a),
\&     newBINOP(OP_MULTIPLY, flags, newSVREF($b), newSVREF($c))
\&  )
.Ve
.PP
See also \*(L"\s-1OP TREES\*(R"\s0 in perlintern
.PP
The simpliest type of an op structure is \f(CW\*(C`OP\*(C'\fR, a \*(L"\s-1BASEOP\*(R"\s0: this
has no children. Unary operators, \*(L"\s-1UNOP\*(R"\s0s, have one child, and
this is pointed to by the \f(CW\*(C`op_first\*(C'\fR field. Binary operators
(\*(L"\s-1BINOP\*(R"\s0s) have not only an \f(CW\*(C`op_first\*(C'\fR field but also an
\&\f(CW\*(C`op_last\*(C'\fR field. The most complex type of op is a \*(L"\s-1LISTOP\*(R"\s0,
which has any number of children. In this case, the first child
is pointed to by \f(CW\*(C`op_first\*(C'\fR and the last child by
\&\f(CW\*(C`op_last\*(C'\fR. The children in between can be found by iteratively
following the \f(CW\*(C`op_sibling\*(C'\fR pointer from the first child to the
last.
.PP
There are also two other op types: a \*(L"\s-1PMOP\*(R"\s0 holds a regular
expression, and has no children, and a \*(L"\s-1LOOP\*(R"\s0 may or may not
have children. If the \f(CW\*(C`op_sibling\*(C'\fR field is non-zero, it behaves
like a \f(CW\*(C`LISTOP\*(C'\fR. To complicate matters, if an \f(CW\*(C`UNOP\*(C'\fR is
actually a null op after optimization (see \*(L"Compile pass 2:
context propagation\*(R" below) it will still have children in
accordance with its former type.
.PP
The beautiful thing about the op tree representation is that it
is a strict 1:1 mapping to the actual source code, which is
proven by the B::Deparse module, which generates readable
source for the current op tree. Well, almost.
.SH "The Compiler"
.IX Header "The Compiler"
Perl's compiler is essentially a 3\-pass compiler with interleaved
phases:
.PP
.Vb 3
\&  1. A bottom\-up pass
\&  2. A top\-down pass
\&  3. An execution\-order pass
.Ve
.SS "Compile pass 1: check routines and constant folding"
.IX Subsection "Compile pass 1: check routines and constant folding"
The bottom-up pass is represented by all the \f(CW"newOP"\fR routines
and the \f(CW\*(C`ck_\*(C'\fR routines. The bottom-upness is actually driven by
\&\fIyacc\fR.  So at the point that a \f(CW\*(C`ck_\*(C'\fR routine fires, we have no
idea what the context is, either upward in the syntax tree, or
either forward or backward in the execution order. The bottom-up
parser builds that part of the execution order it knows about,
but if you follow the \*(L"next\*(R" links around, you'll find it's
actually a closed loop through the top level node.
.PP
So when creating the ops in the first step, still bottom-up, for
each op a check function (\f(CW\*(C`ck_ ()\*(C'\fR) is called, which which
theroretically may destructively modify the whole tree, but
because it knows almost nothing, it mostly just nullifies the
current op. Or it might set the \*(L"op_next\*(R" pointer.  See
\&\*(L"Check Functions\*(R" for more.
.PP
Also, the subsequent constant folding routine \f(CW\*(C`fold_constants()\*(C'\fR
may fold certain arithmetic op sequences. See \*(L"Constant Folding\*(R"
for more.
.SS "Compile pass 2: context propagation"
.IX Subsection "Compile pass 2: context propagation"
The context determines the type of the return value.  When a
context for a part of compile tree is known, it is propagated
down through the tree. At this time the context can have 5 values
(instead of 2 for runtime context): \f(CW\*(C`void\*(C'\fR, \f(CW\*(C`boolean\*(C'\fR,
\&\f(CW\*(C`scalar\*(C'\fR, \f(CW\*(C`list\*(C'\fR, and \f(CW\*(C`lvalue\*(C'\fR. In contrast with the pass 1
this pass is processed from top to bottom: a node's context
determines the context for its children.
.PP
Whenever the bottom-up parser gets to a node that supplies
context to its components, it invokes that portion of the
top-down pass that applies to that part of the subtree (and marks
the top node as processed, so if a node further up supplies
context, it doesn't have to take the plunge again).  As a
particular subcase of this, as the new node is built, it takes
all the closed execution loops of its subcomponents and links
them into a new closed loop for the higher level node.  But it's
still not the real execution order.
.PP
\&\fITodo: Sample\fR
.PP
Additional context-dependent optimizations are performed at this
time. Since at this moment the compile tree contains back-references
(via \*(L"thread\*(R" pointers), nodes cannot be \f(CW\*(C`free()\*(C'\fRd now. To allow
optimized-away nodes at this stage, such nodes are \f(CW\*(C`null()\*(C'\fRified
instead of \f(CW\*(C`free()\*(C'\fR'ing (i.e. their type is changed to \f(CW\*(C`OP_NULL\*(C'\fR).
.SS "Compile pass 3: peephole optimization"
.IX Subsection "Compile pass 3: peephole optimization"
The actual execution order is not known till we get a grammar
reduction to a top-level unit like a subroutine or file that will
be called by \*(L"name\*(R" rather than via a \*(L"next\*(R" pointer.  At that
point, we can call into \fIpeep()\fR to do that code's portion of the
3rd pass.  It has to be recursive, but it's recursive on basic
blocks, not on tree nodes.
.PP
So finally, when the full parse tree is generated, the \*(L"peephole
optimizer\*(R" \f(CW\*(C`peep()\*(C'\fR is running.  This pass is neither top-down
or bottom-up, but in the execution order with additional
complications for conditionals.
.PP
This examines each op in the tree and attempts to determine \*(L"local\*(R"
optimizations by \*(L"thinking ahead\*(R" one or two ops and seeing if
multiple operations can be combined into one (by nullifying and
re-ordering the next pointers).
.PP
It also checks for lexical issues such as the effect of \f(CW\*(C`use
strict\*(C'\fR on bareword constants.  Note that since the last walk the
early sibling pointers for recursive (bottom-up) meta-inspection
are useless, the final exec order is guaranteed by the next and
flags fields.
.PP
If write an rpeep extension by your own, beware that the default mode
of peep is to nullify ops.
.SH "basic vs exec order"
.IX Header "basic vs exec order"
The highly recursive Yacc parser generates the initial op tree in
\&\fBbasic\fR order.  To save memory and run-time the final execution
order of the ops in sequential order is not copied around, just
the next pointers are rehooked in \f(CW\*(C`Perl_linklist()\*(C'\fR to the
so-called \fBexec\fR order.  So the exec walk through the
linked-list of ops is not too cache-friendly.
.PP
In detail \f(CW\*(C`Perl_linklist()\*(C'\fR traverses the op tree, and sets
op-next pointers to give the execution order for that op
tree. op-sibling pointers are rarely unneeded after that.
.PP
Walkers can run in \*(L"basic\*(R" or \*(L"exec\*(R" order.  \*(L"basic\*(R" is useful
for the memory layout, it contains the history, \*(L"exec\*(R" is more
useful to understand the logic and program flow.  The
\&\*(L"B::Bytecode\*(R" section has an extensive example about the order.
.SH "OP Structure and Inheritance"
.IX Header "OP Structure and Inheritance"
The basic \f(CW\*(C`struct op\*(C'\fR looks basically like
.PP
.Vb 1
\&  C<{ OP* op_next, OP* op_sibling, OP* op_ppaddr, ..., int op_flags, int op_private } OP;>
.Ve
.PP
See \*(L"\s-1BASEOP\*(R"\s0 below.
.PP
Each op is defined in size, arguments, return values, class and
more in the \fIopcode.pl\fR table. (See \*(L"\s-1OP\s0 Class Declarations in
opcode.pl\*(R" below.)
.PP
The class of an \s-1OP\s0 determines its size and the number of
children. But the number and type of arguments is not so easy to
declare as in C. \fIopcode.pl\fR tries to declare some XS-prototype
like arguments, but in lisp we would say most ops are \*(L"special\*(R"
functions, context-dependent, with special parsing and precedence rules.
.PP
\&\fIB.pm\fR <http://search.cpan.org/perldoc?B> contains these
classes and inheritance:
.PP
.Vb 10
\&    @B::OP::ISA = \*(AqB::OBJECT\*(Aq;
\&    @B::UNOP::ISA = \*(AqB::OP\*(Aq;
\&    @B::BINOP::ISA = \*(AqB::UNOP\*(Aq;
\&    @B::LOGOP::ISA = \*(AqB::UNOP\*(Aq;
\&    @B::LISTOP::ISA = \*(AqB::BINOP\*(Aq;
\&    @B::SVOP::ISA = \*(AqB::OP\*(Aq;
\&    @B::PADOP::ISA = \*(AqB::OP\*(Aq;
\&    @B::PVOP::ISA = \*(AqB::OP\*(Aq;
\&    @B::LOOP::ISA = \*(AqB::LISTOP\*(Aq;
\&    @B::PMOP::ISA = \*(AqB::LISTOP\*(Aq;
\&    @B::COP::ISA = \*(AqB::OP\*(Aq;
\&    @B::SPECIAL::ISA = \*(AqB::OBJECT\*(Aq;
\&    @B::optype = qw(OP UNOP BINOP LOGOP LISTOP PMOP SVOP PADOP PVOP LOOP COP);
.Ve
.PP
\&\fI\s-1TODO:\s0 ascii graph from perlguts\fR
.PP
\&\fIop.h\fR <http://search.cpan.org/src/JESSE/perl\-5.12.1/op.h>
contains all the gory details. Let's check it out:
.SS "\s-1OP\s0 Class Declarations in opcode.pl"
.IX Subsection "OP Class Declarations in opcode.pl"
The full list of op declarations is defined as \f(CW\*(C`DATA\*(C'\fR in
\&\fIopcode.pl\fR.  It defines the class, the name, some flags, and
the argument types, the so-called \*(L"operands\*(R".  \f(CW\*(C`make regen\*(C'\fR (via
\&\fIregen.pl\fR) recreates out of this \s-1DATA\s0 table the files
\&\fIopcode.h\fR, \fIopnames.h\fR, \fIpp_proto.h\fR and \fIpp.sym\fR.
.PP
The class signifiers in \fIopcode.pl\fR are:
.PP
.Vb 5
\&   baseop      \- 0            unop     \- 1            binop      \- 2
\&   logop       \- |            listop   \- @            pmop       \- /
\&   padop/svop  \- $            padop    \- # (unused)   loop       \- {
\&   baseop/unop \- %            loopexop \- }            filestatop \- \-
\&   pvop/svop   \- "            cop      \- ;
.Ve
.PP
Other options within \fIopcode.pl\fR are:
.PP
.Vb 9
\&   needs stack mark                    \- m
\&   needs constant folding              \- f
\&   produces a scalar                   \- s
\&   produces an integer                 \- i
\&   needs a target                      \- t
\&   target can be in a pad              \- T
\&   has a corresponding integer version \- I
\&   has side effects                    \- d
\&   uses $_ if no argument given        \- u
.Ve
.PP
Values for the operands are:
.PP
.Vb 4
\&   scalar      \- S            list     \- L            array     \- A
\&   hash        \- H            sub (CV) \- C            file      \- F
\&   socket      \- Fs           filetest \- F\-           reference \- R
\&   "?" denotes an optional operand.
.Ve
.SS "\s-1BASEOP\s0"
.IX Subsection "BASEOP"
All op classes have a single character signifier for easier
definition in \fIopcode.pl\fR.  The \s-1BASEOP\s0 class signifier is \fB0\fR,
for no children.
.PP
Below are the \s-1BASEOP\s0 fields, which reflect the object \f(CW\*(C`B::OP\*(C'\fR,
since Perl 5.10.  These are shared for all op classes.  The parts
after \f(CW\*(C`op_type\*(C'\fR and before \f(CW\*(C`op_flags\*(C'\fR changed during history.
.IP "op_next" 4
.IX Item "op_next"
Pointer to next op to execute after this one.
.Sp
Top level pre-grafted op points to first op, but this is replaced
when op is grafted in, when this op will point to the real next
op, and the new parent takes over role of remembering the
starting op.  \fINow, who wrote this prose? Anyway, that is why it
is called guts.\fR
.IP "op_sibling" 4
.IX Item "op_sibling"
Pointer to connect the children's list.
.Sp
The first child is \*(L"op_first\*(R", the last is \*(L"op_last\*(R", and the
children in between are interconnected by op_sibling. This is at
run-time only used for \*(L"\s-1LISTOP\*(R"\s0s.
.Sp
So why is it in the \s-1BASEOP\s0 struct carried around for every op?
.Sp
Because of the complicated Yacc parsing and later optimization
order as explained in \*(L"Compile pass 1: check routines and
constant folding\*(R" the \*(L"op_next\*(R" pointers are not enough, so
op_sibling's are required. The final and fast execution order by
just following the op_next chain is expensive to calculate.
.Sp
See
http://www.xray.mpe.mpg.de/mailing\-lists/perl5\-porters/2006\-09/msg00082.html
for a 20% space-reduction patch to get rid of it at run-time.
.IP "op_ppaddr" 4
.IX Item "op_ppaddr"
Pointer to current ppcode's function.
The so called \*(L"opcode\*(R".
.IP "op_madprop" 4
.IX Item "op_madprop"
Pointer to the \s-1MADPROP\s0 struct. Only with \-DMAD, and since
5.10. See \*(L"\s-1MAD\*(R"\s0 (Misc Attribute Decoration) below.
.IP "op_targ" 4
.IX Item "op_targ"
\&\s-1PADOFFSET\s0 to lexicals vars or when threaded also to GVs. Mainly used
as index into the curpad to access lexical vars. When the op is
nullified the targ holds the previous type.
.IP "op_type" 4
.IX Item "op_type"
The type of the op. See \fIopnames.h\fR
.Sp
Since 5.10 we have the next five fields added, which replace
\&\f(CW\*(C`U16 op_seq\*(C'\fR.
.IP "op_opt" 4
.IX Item "op_opt"
\&\*(L"optimized\*(R"
.Sp
Whether or not the op has been optimised, i.e nullified, by the
peephole optimiser.
.Sp
See the comments in \f(CW\*(C`S_clear_yystack()\*(C'\fR in \fIperly.c\fR for more
details on the following three flags. They are just for freeing
temporary ops on the stack.  But we might have statically
allocated op in the data segment, esp. with the perl compiler's
B::C module. Then we are not allowed to free those static
ops. For a short time, from 5.9.0 until 5.9.4, until the B::C
module was removed from \s-1CORE,\s0 we had another field here for this
reason: \fBop_static\fR.  On 1 it didn't free the static op. Before
5.9.0 the \f(CW\*(C`op_seq\*(C'\fR field was used with the magic value \fB\-1\fR to
indicate a static op, not to be freed.  Note: Trying to free a
static struct is considered harmful.
.IP "op_latefree" 4
.IX Item "op_latefree"
Tell \f(CW\*(C`op_free()\*(C'\fR to clear this op (and free any kids) but not
yet deallocate the struct. This means that the op may be safely
\&\f(CW\*(C`op_free()\*(C'\fRd multiple times.
.Sp
On static ops you just set this to \fB1\fR and after the first
\&\f(CW\*(C`op_free()\*(C'\fR the \f(CW\*(C`op_latefreed\*(C'\fR is automatically set and further
\&\f(CW\*(C`op_free()\*(C'\fR called are just ignored.
.IP "op_latefreed" 4
.IX Item "op_latefreed"
If 1, an \f(CW\*(C`op_latefree\*(C'\fR op has been \f(CW\*(C`op_free()\*(C'\fRd.
.IP "op_attached" 4
.IX Item "op_attached"
This op (sub)tree has been attached to the \s-1CV\s0 \f(CW\*(C`PL_compcv\*(C'\fR so it
doesn't need to be free'd.
.IP "op_spare" 4
.IX Item "op_spare"
Three spare bits in this bitfield above. At least they survived 5.10.
.IP "op_static" 4
.IX Item "op_static"
This op has been allocated statically, usually with the compiler or
within embedded applications. On destruction this op will not be
freed.
.Sp
This bit came and went and came again in various perl versions.  It
was defined until 5.10, and came again with 5.18, because then
latefree was gone.
.Sp
Those last two fields have been in all perls:
.IP "op_flags" 4
.IX Item "op_flags"
Flags common to all operations.
See \f(CW\*(C`OPf_*\*(C'\fR in \fIop.h\fR, or more verbose in B::Flags or \fIdump.c\fR
.IP "op_private" 4
.IX Item "op_private"
Flags peculiar to a particular operation (\s-1BUT,\s0 by default, set to
the number of children until the operation is privatized by a
check routine, which may or may not check number of children).
.Sp
This flag is normally used to hold op specific context hints,
such as \f(CW\*(C`HINT_INTEGER\*(C'\fR. This flag is directly attached to each
relevant op in the subtree of the context. Note that there's no
general context or class pointer for each op, a typical
functional language usually holds this in the ops arguments.  So
we are limited to max 32 lexical pragma hints or less. See
\&\*(L"Lexical Pragmas\*(R".
.PP
The exact op.h \*(L"\s-1BASEOP\*(R"\s0 history for the parts after \f(CW\*(C`op_type\*(C'\fR and
before \f(CW\*(C`op_flags\*(C'\fR is:
.PP
.Vb 4
\&  <=5.8:   U16 op_seq;
\&    5.9.4: unsigned op_opt:1; unsigned op_static:1;   unsigned op_spare:5;
\&  >=5.10:  unsigned op_opt:1; unsigned op_latefree:1; unsigned op_latefreed:1; 
\&           unsigned op_attached:1; unsigned op_spare:3;
.Ve
.PP
The \*(L"\s-1BASEOP\*(R"\s0 class signifier is \fB0\fR, for no children.
The full list of all \s-1BASEOP\s0's is:
.PP
.Vb 10
\&        $ perl \-F"/\ecI+/" \-ane \*(Aqprint if $F[3] =~ /0$/\*(Aq opcode.pl
\&        null          null operation          ck_null         0
\&        stub          stub                    ck_null         0
\&        pushmark      pushmark                ck_null         s0
\&        wantarray     wantarray               ck_null         is0
\&        padsv         private variable        ck_null         ds0
\&        padav         private array           ck_null         d0
\&        padhv         private hash            ck_null         d0
\&        padany        private value           ck_null         d0
\&        sassign       scalar assignment       ck_sassign      s0
\&        unstack       iteration finalizer     ck_null         s0
\&        enter         block entry             ck_null         0
\&        iter          foreach loop iterator   ck_null         0
\&        break         break                   ck_null         0
\&        continue      continue                ck_null         0
\&        fork          fork                    ck_null         ist0
\&        wait          wait                    ck_null         isT0
\&        getppid       getppid                 ck_null         isT0
\&        time          time                    ck_null         isT0
\&        tms           times                   ck_null         0
\&        ghostent      gethostent              ck_null         0
\&        gnetent       getnetent               ck_null         0
\&        gprotoent     getprotoent             ck_null         0
\&        gservent      getservent              ck_null         0
\&        ehostent      endhostent              ck_null         is0
\&        enetent       endnetent               ck_null         is0
\&        eprotoent     endprotoent             ck_null         is0
\&        eservent      endservent              ck_null         is0
\&        gpwent        getpwent                ck_null         0
\&        spwent        setpwent                ck_null         is0
\&        epwent        endpwent                ck_null         is0
\&        ggrent        getgrent                ck_null         0
\&        sgrent        setgrent                ck_null         is0
\&        egrent        endgrent                ck_null         is0
\&        getlogin      getlogin                ck_null         st0
\&        custom        unknown custom operator ck_null         0
.Ve
.PP
\fInull\fR
.IX Subsection "null"
.PP
null ops are skipped during the runloop, and are created by the peephole optimizer.
.SS "\s-1UNOP\s0"
.IX Xref "op_first"
.IX Subsection "UNOP"
The unary op class signifier is \fB1\fR, for one child, pointed to
by \f(CW\*(C`op_first\*(C'\fR.
.PP
.Vb 4
\&        struct unop {
\&                BASEOP
\&                OP *    op_first;
\&        }
\&
\&        $ perl \-F"/\ecI+/" \-ane \*(Aqprint if $F[3] =~ /1$/\*(Aq opcode.pl
\&        rv2gv           ref\-to\-glob cast        ck_rvconst      ds1
\&        rv2sv           scalar dereference      ck_rvconst      ds1
\&        av2arylen       array length            ck_null         is1
\&        rv2cv           subroutine dereference  ck_rvconst      d1
\&        refgen          reference constructor   ck_spair        m1      L
\&        srefgen         single ref constructor  ck_null         fs1     S
\&        regcmaybe       regexp internal guard   ck_fun          s1      S
\&        regcreset       regexp internal reset   ck_fun          s1      S
\&        preinc          preincrement (++)       ck_lfun         dIs1    S
\&        i_preinc        integer preincrement (++) ck_lfun       dis1    S
\&        predec          predecrement (\-\-)       ck_lfun         dIs1    S
\&        i_predec        integer predecrement (\-\-) ck_lfun       dis1    S
\&        postinc         postincrement (++)      ck_lfun         dIst1   S
\&        i_postinc       integer postincrement (++) ck_lfun      disT1   S
\&        postdec         postdecrement (\-\-)      ck_lfun         dIst1   S
\&        i_postdec       integer postdecrement (\-\-) ck_lfun      disT1   S
\&        negate          negation (\-)            ck_null         Ifst1   S
\&        i_negate        integer negation (\-)    ck_null         ifsT1   S
\&        not             not                     ck_null         ifs1    S
\&        complement      1\*(Aqs complement (~)      ck_bitop        fst1    S
\&        rv2av           array dereference       ck_rvconst      dt1
\&        rv2hv           hash dereference        ck_rvconst      dt1
\&        flip            range (or flip)         ck_null         1       S S
\&        flop            range (or flop)         ck_null         1
\&        method          method lookup           ck_method       d1
\&        entersub        subroutine entry        ck_subr         dmt1    L
\&        leavesub        subroutine exit         ck_null         1
\&        leavesublv      lvalue subroutine return ck_null        1
\&        leavegiven      leave given block       ck_null         1
\&        leavewhen       leave when block        ck_null         1
\&        leavewrite      write exit              ck_null         1
\&        dofile          do "file"               ck_fun          d1      S
\&        leaveeval       eval "string" exit      ck_null         1       S
\&        #evalonce       eval constant string    ck_null         d1      S
.Ve
.SS "\s-1BINOP\s0"
.IX Xref "op_last"
.IX Subsection "BINOP"
The \s-1BINOP\s0 class signifier is \fB2\fR, for two children, pointed to by
\&\f(CW\*(C`op_first\*(C'\fR and \f(CW\*(C`op_last\*(C'\fR.
.PP
.Vb 5
\&        struct binop {
\&                BASEOP
\&                OP *    op_first;
\&                OP *    op_last;
\&        }
\&
\&        $ perl \-F"/\ecI+/" \-ane \*(Aqprint if $F[3] =~ /2$/\*(Aq opcode.pl
\&        gelem           glob elem               ck_null         d2      S S
\&        aassign         list assignment         ck_null         t2      L L
\&        pow             exponentiation (**)     ck_null         fsT2    S S
\&        multiply        multiplication (*)      ck_null         IfsT2   S S
\&        i_multiply      integer multiplication (*) ck_null      ifsT2   S S
\&        divide          division (/)            ck_null         IfsT2   S S
\&        i_divide        integer division (/)    ck_null         ifsT2   S S
\&        modulo          modulus (%)             ck_null         IifsT2  S S
\&        i_modulo        integer modulus (%)     ck_null         ifsT2   S S
\&        repeat          repeat (x)              ck_repeat       mt2     L S
\&        add             addition (+)            ck_null         IfsT2   S S
\&        i_add           integer addition (+)    ck_null         ifsT2   S S
\&        subtract        subtraction (\-)         ck_null         IfsT2   S S
\&        i_subtract      integer subtraction (\-) ck_null         ifsT2   S S
\&        concat          concatenation (.) or string ck_concat   fsT2    S S
\&        left_shift      left bitshift (<<)      ck_bitop        fsT2    S S
\&        right_shift     right bitshift (>>)     ck_bitop        fsT2    S S
\&        lt              numeric lt (<)          ck_null         Iifs2   S S
\&        i_lt            integer lt (<)          ck_null         ifs2    S S
\&        gt              numeric gt (>)          ck_null         Iifs2   S S
\&        i_gt            integer gt (>)          ck_null         ifs2    S S
\&        le              numeric le (<=)         ck_null         Iifs2   S S
\&        i_le            integer le (<=)         ck_null         ifs2    S S
\&        ge              numeric ge (>=)         ck_null         Iifs2   S S
\&        i_ge            integer ge (>=)         ck_null         ifs2    S S
\&        eq              numeric eq (==)         ck_null         Iifs2   S S
\&        i_eq            integer eq (==)         ck_null         ifs2    S S
\&        ne              numeric ne (!=)         ck_null         Iifs2   S S
\&        i_ne            integer ne (!=)         ck_null         ifs2    S S
\&        ncmp            numeric comparison (<=>)ck_null         Iifst2  S S
\&        i_ncmp          integer comparison (<=>)ck_null         ifst2   S S
\&        slt             string lt               ck_null         ifs2    S S
\&        sgt             string gt               ck_null         ifs2    S S
\&        sle             string le               ck_null         ifs2    S S
\&        sge             string ge               ck_null         ifs2    S S
\&        seq             string eq               ck_null         ifs2    S S
\&        sne             string ne               ck_null         ifs2    S S
\&        scmp            string comparison (cmp) ck_null         ifst2   S S
\&        bit_and         bitwise and (&)         ck_bitop        fst2    S S
\&        bit_xor         bitwise xor (^)         ck_bitop        fst2    S S
\&        bit_or          bitwise or (|)          ck_bitop        fst2    S S
\&        smartmatch      smart match             ck_smartmatch   s2
\&        aelem           array element           ck_null         s2      A S
\&        helem           hash element            ck_null         s2      H S
\&        lslice          list slice              ck_null         2       H L L
\&        xor             logical xor             ck_null         fs2     S S
\&        leaveloop       loop exit               ck_null         2
.Ve
.SS "\s-1LOGOP\s0"
.IX Xref "op_other"
.IX Subsection "LOGOP"
The \s-1LOGOP\s0 class signifier is \fB|\fR.
.PP
A \s-1LOGOP\s0 has the same structure as a \*(L"\s-1BINOP\*(R"\s0, two children, just the
second field has another name \f(CW\*(C`op_other\*(C'\fR instead of \f(CW\*(C`op_last\*(C'\fR.
But as you see on the list below, the two arguments as above are optional and 
not strictly required.
.PP
.Vb 5
\&        struct logop {
\&                BASEOP
\&                OP *    op_first;
\&                OP *    op_other;
\&        };
\&
\&        $ perl \-F"/\ecI+/" \-ane \*(Aqprint if $F[3] =~ /\e|$/\*(Aq opcode.pl
\&        regcomp         regexp compilation      ck_null         s|      S
\&        substcont       substitution iterator   ck_null         dis|
\&        grepwhile       grep iterator           ck_null         dt|
\&        mapwhile        map iterator            ck_null         dt|
\&        range           flipflop                ck_null         |       S S
\&        and             logical and (&&)        ck_null         |
\&        or              logical or (||)         ck_null         |
\&        dor             defined or (//)         ck_null         |
\&        cond_expr       conditional expression  ck_null         d|
\&        andassign       logical and assignment (&&=) ck_null    s|
\&        orassign        logical or assignment (||=)  ck_null    s|
\&        dorassign       defined or assignment (//=)  ck_null    s|
\&        entergiven      given()                 ck_null         d|
\&        enterwhen       when()                  ck_null         d|
\&        entertry        eval {block}            ck_null         |
\&        once            once                    ck_null         |
.Ve
.PP
\fIand\fR
.IX Subsection "and"
.PP
Checks for falseness on the first argument on the stack.
If false, returns immediately, keeping the false value on the stack.
If true pops the stack, and returns the op at \f(CW\*(C`op_other\*(C'\fR.
.PP
Note: \fBand\fR is also used for a simple \fBif\fR without \fBelse\fR/\fBelsif\fR. 
The general \fBif\fR is done with cond_expr.
.PP
\fIcond_expr\fR
.IX Subsection "cond_expr"
.PP
Checks for trueness on the first argument on the stack.
If true returns the op at \f(CW\*(C`op_other\*(C'\fR, if false \f(CW\*(C`op_next\*(C'\fR.
.PP
Note: A simple \fBif\fR without else is done by and.
.SS "\s-1LISTOP\s0"
.IX Xref "op_last"
.IX Subsection "LISTOP"
The \s-1LISTOP\s0 class signifier is \fB@\fR.
.PP
.Vb 5
\&        struct listop {
\&                BASEOP
\&                OP *    op_first;
\&                OP *    op_last;
\&        };
.Ve
.PP
This is most complex type, it may have any number of children. The
first child is pointed to by \f(CW\*(C`op_first\*(C'\fR and the last child by
\&\f(CW\*(C`op_last\*(C'\fR. The children in between can be found by iteratively
following the \f(CW\*(C`op_sibling\*(C'\fR pointer from the first child to the last.
.PP
At all 99 ops from 366 are \s-1LISTOP\s0's. This is the least
restrictive format, that's why.
.PP
.Vb 10
\&        $ perl \-F"/\ecI+/" \-ane \*(Aqprint if $F[3] =~ /\e@$/\*(Aq opcode.pl
\&        bless           bless                   ck_fun          s@      S S?
\&        glob            glob                    ck_glob         t@      S?
\&        stringify       string                  ck_fun          fsT@    S
\&        atan2           atan2                   ck_fun          fsT@    S S
\&        substr          substr                  ck_substr       st@     S S S? S?
\&        vec             vec                     ck_fun          ist@    S S S
\&        index           index                   ck_index        isT@    S S S?
\&        rindex          rindex                  ck_index        isT@    S S S?
\&        sprintf         sprintf                 ck_fun          fmst@   S L
\&        formline        formline                ck_fun          ms@     S L
\&        crypt           crypt                   ck_fun          fsT@    S S
\&        aslice          array slice             ck_null         m@      A L
\&        hslice          hash slice              ck_null         m@      H L
\&        unpack          unpack                  ck_unpack       @       S S?
\&        pack            pack                    ck_fun          mst@    S L
\&        split           split                   ck_split        t@      S S S
\&        join            join or string          ck_join         mst@    S L
\&        list            list                    ck_null         m@      L
\&        anonlist        anonymous list ([])     ck_fun          ms@     L
\&        anonhash        anonymous hash ({})     ck_fun          ms@     L
\&        splice          splice                  ck_fun          m@      A S? S? L
\&        ... and so on, until
\&        syscall         syscall                 ck_fun          imst@   S L
.Ve
.SS "\s-1PMOP\s0"
.IX Subsection "PMOP"
The \s-1PMOP\s0 \*(L"pattern matching\*(R" class signifier is \fB/\fR for matching.
It inherits from the \*(L"\s-1LISTOP\*(R"\s0.
.PP
The internal struct changed completely with 5.10, as the
underlying engine.  Starting with 5.11 the \s-1PMOP\s0 can even hold
native \*(L"perlguts#REGEX\*(R" in \*(L"\s-1REGEX\*(R"\s0 objects, not just \s-1SV\s0's.  So you
have to use the \f(CW\*(C`PM\*(C'\fR macros to stay compatible.
.PP
Below is the current \f(CW\*(C`struct pmop\*(C'\fR. You will not like it.
.PP
.Vb 10
\&        struct pmop {
\&            BASEOP
\&            OP *        op_first;
\&            OP *        op_last;
\&        #ifdef USE_ITHREADS
\&            IV          op_pmoffset;
\&        #else
\&            REGEXP *    op_pmregexp;            /* compiled expression */
\&        #endif
\&            U32         op_pmflags;
\&            union {
\&                OP *    op_pmreplroot;          /* For OP_SUBST */
\&        #ifdef USE_ITHREADS
\&                PADOFFSET  op_pmtargetoff;      /* For OP_PUSHRE */
\&        #else
\&                GV *    op_pmtargetgv;
\&        #endif
\&            }   op_pmreplrootu;
\&            union {
\&                OP *    op_pmreplstart; /* Only used in OP_SUBST */
\&        #ifdef USE_ITHREADS
\&                char *  op_pmstashpv;   /* Only used in OP_MATCH, with PMf_ONCE set */
\&        #else
\&                HV *    op_pmstash;
\&        #endif
\&            }           op_pmstashstartu;
\&        };
.Ve
.PP
Before we had no union, but a \f(CW\*(C`op_pmnext\*(C'\fR, which never worked. 
Maybe because of the typo in the comment.
.PP
The old struct (up to 5.8.x) was as simple as:
.PP
.Vb 10
\&        struct pmop {
\&            BASEOP
\&            OP *        op_first;
\&            OP *        op_last;
\&            U32         op_children;
\&            OP *        op_pmreplroot;
\&            OP *        op_pmreplstart;
\&            PMOP *      op_pmnext;              /* list of all scanpats */
\&            REGEXP *    op_pmregexp;            /* compiled expression */
\&            U16         op_pmflags;
\&            U16         op_pmpermflags;
\&            U8          op_pmdynflags;
\&        }
.Ve
.PP
So \f(CW\*(C`op_pmnext\*(C'\fR, \f(CW\*(C`op_pmpermflags\*(C'\fR and \f(CW\*(C`op_pmdynflags\*(C'\fR are gone. 
The \f(CW\*(C`op_pmflags\*(C'\fR are not the whole deal, there's also \f(CW\*(C`op_pmregexp.extflags\*(C'\fR 
\&\- interestingly called \f(CW\*(C`B::PMOP::reflags\*(C'\fR in B \- for the new features.
This is btw. the only inconsistency in the B mapping.
.PP
.Vb 5
\&        $ perl \-F"/\ecI+/" \-ane \*(Aqprint if $F[3] =~ /\e/$/\*(Aq opcode.pl
\&        pushre          push regexp             ck_null         d/
\&        match           pattern match (m//)     ck_match        d/
\&        qr              pattern quote (qr//)    ck_match        s/
\&        subst           substitution (s///)     ck_match        dis/    S
.Ve
.SS "\s-1SVOP\s0"
.IX Subsection "SVOP"
The \s-1SVOP\s0 class is very special, and can even change dynamically.
Whole \s-1SV\s0's are costly and are now just used as \s-1GV\s0 or \s-1RV.\s0
The \s-1SVOP\s0 has no special signifier, as there are different subclasses.
See \*(L"\s-1SVOP_OR_PADOP\*(R"\s0, \*(L"\s-1PVOP_OR_SVOP\*(R"\s0 and \*(L"\s-1FILESTATOP\*(R"\s0.
.PP
A \s-1SVOP\s0 holds a \s-1SV\s0 and is in case of an \s-1FILESTATOP\s0 the \s-1GV\s0 for the 
filehandle argument, and in case of \f(CW\*(C`trans\*(C'\fR (a \*(L"\s-1PVOP\*(R"\s0) with utf8 a 
reference to a swash (i.e., an \s-1RV\s0 pointing to an \s-1HV\s0).
.PP
.Vb 4
\&        struct svop {
\&                BASEOP
\&                SV *    op_sv;
\&        };
.Ve
.PP
Most old \s-1SVOP\s0's were changed to \*(L"\s-1PADOP\*(R"\s0's when threading was introduced, to
privatize the global \s-1SV\s0 area to thread-local scratchpads.
.PP
\fI\s-1SVOP_OR_PADOP\s0\fR
.IX Subsection "SVOP_OR_PADOP"
.PP
The op \f(CW\*(C`aelemfast\*(C'\fR is either a \s-1PADOP\s0 with threading and a simple \s-1SVOP\s0 without. 
This is thanksfully known at compile-time.
.PP
.Vb 1
\&    aelemfast   constant array element  ck_null         s$      A S
.Ve
.PP
\fI\s-1PVOP_OR_SVOP\s0\fR
.IX Subsection "PVOP_OR_SVOP"
.PP
The only op here is \f(CW\*(C`trans\*(C'\fR, where the class is dynamically defined, 
dependent on the utf8 settings in the \*(L"op_private\*(R" hints.
.PP
.Vb 3
\&    case OA_PVOP_OR_SVOP:
\&        return (o\->op_private & (OPpTRANS_TO_UTF|OPpTRANS_FROM_UTF))
\&                ? OPc_SVOP : OPc_PVOP;
\&
\&    trans               transliteration (tr///) ck_null         is"     S
.Ve
.PP
Character translations (\f(CW\*(C`tr///\*(C'\fR) are usually a \s-1PVOP\s0, keeping a pointer
to a table of shorts used to look up translations.  Under utf8,
however, a simple table isn't practical; instead, the \s-1OP\s0 is an \*(L"\s-1SVOP\*(R"\s0,
and the \s-1SV\s0 is a reference to a \fBswash\fR, i.e. a \s-1RV\s0 pointing to an \s-1HV.\s0
.SS "\s-1PADOP\s0"
.IX Subsection "PADOP"
The \s-1PADOP\s0 class signifier is \fB$\fR for temp. scalars.
.PP
A new \f(CW\*(C`PADOP\*(C'\fR creates a new temporary scratchpad, an \s-1PADLIST\s0 array.
  \f(CW\*(C`padop\-\*(C'\fRop_padix = pad_alloc(type, SVs_PADTMP);>
\&\f(CW\*(C`SVs_PADTMP\*(C'\fR are targets/GVs/constants with undef names.
.PP
A \f(CW\*(C`PADLIST\*(C'\fR scratchpad is a special context stack, a array-of-array data structure 
attached to a \s-1CV\s0 (i.e. a sub), to store lexical variables and opcode temporary and 
per-thread values. See \*(L"Scratchpads\*(R" in perlguts.
.PP
Only my/our variable (\f(CW\*(C`SVs_PADMY\*(C'\fR/\f(CW\*(C`SVs_PADOUR\*(C'\fR) slots get valid names.
The rest are op targets/GVs/constants which are statically allocated
or resolved at compile time.  These don't have names by which they
can be looked up from Perl code at run time through eval "\*(L" like
my/our variables can be.  Since they can't be looked up by \*(R"name"
but only by their index allocated at compile time (which is usually
in \f(CW\*(C`op_targ\*(C'\fR), wasting a name \s-1SV\s0 for them doesn't make sense.
.PP
.Vb 4
\&        struct padop {
\&                BASEOP
\&                PADOFFSET       op_padix;
\&        };
\&
\&        $ perl \-F"/\ecI+/" \-ane \*(Aqprint if $F[3] =~ /\e$$/\*(Aq opcode.pl
\&        const           constant item           ck_svconst      s$
\&        gvsv            scalar variable         ck_null         ds$
\&        gv              glob value              ck_null         ds$
\&        anoncode        anonymous subroutine    ck_anoncode     $
\&        rcatline        append I/O operator     ck_null         t$
\&        aelemfast       constant array element  ck_null         s$      A S
\&        method_named    method with known name  ck_null         d$
\&        hintseval       eval hints              ck_svconst      s$
.Ve
.SS "\s-1PVOP\s0"
.IX Subsection "PVOP"
This is a simple unary op, holding a string. 
The only \s-1PVOP\s0 is \f(CW\*(C`trans\*(C'\fR op for \*(L"//\*(R" in tr.
See above at \*(L"\s-1PVOP_OR_SVOP\*(R"\s0 for the dynamic nature of trans with utf8.
.PP
The \s-1PVOP\s0 class signifier is \f(CW\*(C`"\*(C'\fR for strings.
.PP
.Vb 4
\&        struct pvop {
\&                BASEOP
\&                char *  op_pv;
\&        };
\&
\&        $ perl \-F"/\ecI+/" \-ane \*(Aqprint if $F[3] =~ /\e"$/\*(Aq opcode.pl
\&        trans           transliteration (tr///) ck_match        is"     S
.Ve
.SS "\s-1LOOP\s0"
.IX Subsection "LOOP"
The \s-1LOOP\s0 class signifier is \fB{\fR.
It inherits from the \*(L"\s-1LISTOP\*(R"\s0.
.PP
.Vb 8
\&        struct loop {
\&            BASEOP
\&            OP * op_first;
\&            OP * op_last;
\&            OP * op_redoop;
\&            OP * op_nextop;
\&            OP * op_lastop;
\&        };
\&
\&        $ perl \-F"/\ecI+/" \-ane \*(Aqprint if $F[3] =~ /\e{$/\*(Aq opcode.pl
\&        enteriter       foreach loop entry      ck_null         d{
\&        enterloop       loop entry              ck_null         d{
.Ve
.SS "\s-1COP\s0"
.IX Subsection "COP"
The \f(CW\*(C`struct cop\*(C'\fR, the \*(L"Control \s-1OP\*(R",\s0 changed recently a lot, as the \*(L"\s-1BASEOP\*(R"\s0.
Remember from perlguts what a \s-1COP\s0 is? Got you. A \s-1COP\s0 is nowhere described.
.PP
I would have naively called it \*(L"Context \s-1OP\*(R",\s0 but not \*(L"Control \s-1OP\*(R".\s0 So why?
We have a global \f(CW\*(C`PL_curcop\*(C'\fR and then we have threads. So it cannot be global
anymore. A \s-1COP\s0 can be said as helper context for debugging and error information
to store away file and line information. But since perl is a file-based
compiler, not block-based, also file based pragmata and hints are stored in the
\&\s-1COP.\s0 So we have for every source file a seperate \s-1COP. COP\s0's are mostly not 
really block level contexts, just file and line information. The block level 
contexts are not controlled via \s-1COP\s0's, but global \f(CW\*(C`Cx\*(C'\fR structs.
.PP
\&\fIcop.h\fR says:
.PP
Control ops (cops) are one of the two ops \s-1OP_NEXTSTATE\s0 and \s-1OP_DBSTATE\s0 
that (loosely speaking) are separate statements. They hold
information for lexical state and error reporting. At run time, \f(CW\*(C`PL_curcop\*(C'\fR is set
to point to the most recently executed cop, and thus can be used to determine
our file-level current state.
.PP
But we need block context, eval context, subroutine context, loop context, and
even format context. All these are seperate structs defined in \fIcop.h\fR.
.PP
So the COPs are not really that important, as the actual \f(CW\*(C`Cx\*(C'\fR context structs
are. Just the \f(CW\*(C`CopSTASH\*(C'\fR is, the current package symbol table hash (\*(L"stash\*(R").
.PP
Another famous \s-1COP\s0 is \f(CW\*(C`PL_compiling\*(C'\fR, which sets the temporary compilation
environment.
.PP
.Vb 10
\&        struct cop {
\&            BASEOP
\&            line_t      cop_line;       /* line # of this command */
\&            char *      cop_label;      /* label for this construct */
\&        #ifdef USE_ITHREADS
\&            char *      cop_stashpv;    /* package line was compiled in */
\&            char *      cop_file;       /* file name the following line # is from */
\&        #else
\&            HV *        cop_stash;      /* package line was compiled in */
\&            GV *        cop_filegv;     /* file the following line # is from */
\&        #endif
\&            U32         cop_hints;      /* hints bits from pragmata */
\&            U32         cop_seq;        /* parse sequence number */
\&            /* Beware. mg.c and warnings.pl assume the type of this is STRLEN *:  */
\&            STRLEN *    cop_warnings;   /* lexical warnings bitmask */
\&            /* compile time state of %^H.  See the comment in op.c for how this is
\&               used to recreate a hash to return from caller.  */
\&            struct refcounted_he * cop_hints_hash;
\&        };
.Ve
.PP
The \s-1COP\s0 class signifier is \fB;\fR and there are only two:
.PP
.Vb 3
\&        $ perl \-F"/\ecI+/" \-ane \*(Aqprint if $F[3] =~ /;$/\*(Aq opcode.pl
\&        nextstate       next statement          ck_null         s;
\&        dbstate         debug next statement    ck_null         s;
.Ve
.PP
\&\f(CW\*(C`NEXTSTATE\*(C'\fR is replaced by \f(CW\*(C`DBSTATE\*(C'\fR when you call perl with \-d, the
debugger.  You can even patch the \f(CW\*(C`NEXTSTATE\*(C'\fR ops at runtime to
\&\f(CW\*(C`DBSTATE\*(C'\fR as done in the module \f(CW\*(C`Enbugger\*(C'\fR.
.PP
For a short time there used to be three. \f(CW\*(C`SETSTATE\*(C'\fR was
added 1999 (pre Perl 5.6.0) to track linenumbers correctly
in optimized blocks, disabled 1999 with change 4309 for Perl
5.6.0, and removed with 5edb5b2abb at Perl 5.10.1.
.SS "\s-1BASEOP_OR_UNOP\s0"
.IX Subsection "BASEOP_OR_UNOP"
\&\s-1BASEOP_OR_UNOP\s0 has the class signifier \fB%\fR. As the name says, it may 
be a \*(L"\s-1BASEOP\*(R"\s0 or \*(L"\s-1UNOP\*(R"\s0, it may have an optional \*(L"op_first\*(R" field.
.PP
The list of \fB%\fR ops is quite large, it has 84 ops.
Some of them are e.g.
.PP
.Vb 10
\&        $ perl \-F"/\ecI+/" \-ane \*(Aqprint if $F[3] =~ /%$/\*(Aq opcode.pl
\&        ...
\&        quotemeta       quotemeta               ck_fun          fstu%   S?
\&        aeach           each on array           ck_each         %       A
\&        akeys           keys on array           ck_each         t%      A
\&        avalues         values on array         ck_each         t%      A
\&        each            each                    ck_each         %       H
\&        values          values                  ck_each         t%      H
\&        keys            keys                    ck_each         t%      H
\&        delete          delete                  ck_delete       %       S
\&        exists          exists                  ck_exists       is%     S
\&        pop             pop                     ck_shift        s%      A?
\&        shift           shift                   ck_shift        s%      A?
\&        caller          caller                  ck_fun          t%      S?
\&        reset           symbol reset            ck_fun          is%     S?
\&        exit            exit                    ck_exit         ds%     S?
\&        ...
.Ve
.SS "\s-1FILESTATOP\s0"
.IX Subsection "FILESTATOP"
A \s-1FILESTATOP\s0 may be a \*(L"\s-1UNOP\*(R"\s0, \*(L"\s-1PADOP\*(R"\s0, \*(L"\s-1BASEOP\*(R"\s0 or \*(L"\s-1SVOP\*(R"\s0.
.PP
It has the class signifier \fB\-\fR.
.PP
The file stat OPs are created via \s-1UNI\s0(OP_foo) in toke.c but use the
\&\f(CW\*(C`OPf_REF\*(C'\fR flag to distinguish between \s-1OP\s0 types instead of the usual
\&\f(CW\*(C`OPf_SPECIAL\*(C'\fR flag. As usual, if \f(CW\*(C`OPf_KIDS\*(C'\fR is set, then we return
\&\f(CW\*(C`OPc_UNOP\*(C'\fR so that \f(CW\*(C`walkoptree\*(C'\fR can find our children. If \f(CW\*(C`OPf_KIDS\*(C'\fR is not
set then we check \f(CW\*(C`OPf_REF\*(C'\fR. Without \f(CW\*(C`OPf_REF\*(C'\fR set (no argument to the
operator) it's an \s-1OP\s0; with \f(CW\*(C`OPf_REF\*(C'\fR set it's an \s-1SVOP\s0 (and the field \f(CW\*(C`op_sv\*(C'\fR is the
\&\s-1GV\s0 for the filehandle argument).
.PP
.Vb 7
\&  case OA_FILESTATOP:
\&        return ((o\->op_flags & OPf_KIDS) ? OPc_UNOP :
\&  #ifdef USE_ITHREADS
\&                (o\->op_flags & OPf_REF) ? OPc_PADOP : OPc_BASEOP);
\&  #else
\&                (o\->op_flags & OPf_REF) ? OPc_SVOP : OPc_BASEOP);
\&  #endif
\&
\&
\&        lstat           lstat                   ck_ftst         u\-      F
\&        stat            stat                    ck_ftst         u\-      F
\&        ftrread         \-R                      ck_ftst         isu\-    F\-+
\&        ftrwrite        \-W                      ck_ftst         isu\-    F\-+
\&        ftrexec         \-X                      ck_ftst         isu\-    F\-+
\&        fteread         \-r                      ck_ftst         isu\-    F\-+
\&        ftewrite        \-w                      ck_ftst         isu\-    F\-+
\&        fteexec         \-x                      ck_ftst         isu\-    F\-+
\&        ftis            \-e                      ck_ftst         isu\-    F\-
\&        ftsize          \-s                      ck_ftst         istu\-   F\-
\&        ftmtime         \-M                      ck_ftst         stu\-    F\-
\&        ftatime         \-A                      ck_ftst         stu\-    F\-
\&        ftctime         \-C                      ck_ftst         stu\-    F\-
\&        ftrowned        \-O                      ck_ftst         isu\-    F\-
\&        fteowned        \-o                      ck_ftst         isu\-    F\-
\&        ftzero          \-z                      ck_ftst         isu\-    F\-
\&        ftsock          \-S                      ck_ftst         isu\-    F\-
\&        ftchr           \-c                      ck_ftst         isu\-    F\-
\&        ftblk           \-b                      ck_ftst         isu\-    F\-
\&        ftfile          \-f                      ck_ftst         isu\-    F\-
\&        ftdir           \-d                      ck_ftst         isu\-    F\-
\&        ftpipe          \-p                      ck_ftst         isu\-    F\-
\&        ftsuid          \-u                      ck_ftst         isu\-    F\-
\&        ftsgid          \-g                      ck_ftst         isu\-    F\-
\&        ftsvtx          \-k                      ck_ftst         isu\-    F\-
\&        ftlink          \-l                      ck_ftst         isu\-    F\-
\&        fttty           \-t                      ck_ftst         is\-     F\-
\&        fttext          \-T                      ck_ftst         isu\-    F\-
\&        ftbinary        \-B                      ck_ftst         isu\-    F\-
.Ve
.SS "\s-1LOOPEXOP\s0"
.IX Subsection "LOOPEXOP"
A \s-1LOOPEXOP\s0 is almost a \s-1BASEOP_OR_UNOP\s0. It may be a \*(L"\s-1UNOP\*(R"\s0 if stacked or 
\&\*(L"\s-1BASEOP\*(R"\s0 if special or \*(L"\s-1PVOP\*(R"\s0 else.
.PP
\&\f(CW\*(C`next\*(C'\fR, \f(CW\*(C`last\*(C'\fR, \f(CW\*(C`redo\*(C'\fR, \f(CW\*(C`dump\*(C'\fR and \f(CW\*(C`goto\*(C'\fR use \f(CW\*(C`OPf_SPECIAL\*(C'\fR to indicate that a
label was omitted (in which case it's a \*(L"\s-1BASEOP\*(R"\s0) or else a term was
seen. In this last case, all except goto are definitely \*(L"\s-1PVOP\*(R"\s0 but
goto is either a \s-1PVOP\s0 (with an ordinary constant label), an \*(L"\s-1UNOP\*(R"\s0
with \f(CW\*(C`OPf_STACKED\*(C'\fR (with a non-constant non-sub) or an \*(L"\s-1UNOP\*(R"\s0 for
\&\f(CW\*(C`OP_REFGEN\*(C'\fR (with \f(CW\*(C`goto &sub\*(C'\fR) in which case \f(CW\*(C`OPf_STACKED\*(C'\fR also seems to
get set.
.PP
\&...
.SS "\s-1OP\s0 Definition Example"
.IX Subsection "OP Definition Example"
Let's take a simple example for a opcode definition in \fIopcode.pl\fR:
.PP
.Vb 1
\&  left_shift    left bitshift (<<)      ck_bitop        fsT2    S S
.Ve
.PP
The op \f(CW\*(C`left_shift\*(C'\fR has a check function \f(CW\*(C`ck_bitop\*(C'\fR (normally most ops 
have no check function, just \f(CW\*(C`ck_null\*(C'\fR), and the options \f(CW\*(C`fsT2\*(C'\fR.
The last two \f(CW\*(C`S S\*(C'\fR describe the type of the two required operands: 
\&\s-1SV\s0 or scalar. This is similar to \s-1XS\s0 protoypes.
The last \f(CW2\fR in the options \f(CW\*(C`fsT2\*(C'\fR denotes the class \s-1BINOP,\s0 with 
two args on the stack.
Every binop takes two args and this produces one scalar, see the \f(CW\*(C`s\*(C'\fR flag.
The other remaining flags are \f(CW\*(C`f\*(C'\fR and \f(CW\*(C`T\*(C'\fR.
.PP
\&\f(CW\*(C`f\*(C'\fR tells the compiler in the first pass to call \f(CW\*(C`fold_constants()\*(C'\fR 
on this op. See \*(L"Compile pass 1: check routines and constant folding\*(R"
If both args are constant, the result is constant also and the op will 
be nullified.
.PP
Now let's inspect the simple definition of this op in \fIpp.c\fR.
\&\f(CW\*(C`pp_left_shift\*(C'\fR is the \f(CW\*(C`op_ppaddr\*(C'\fR, the function pointer, for every 
left_shift op.
.PP
.Vb 10
\&  PP(pp_left_shift)
\&  {
\&    dVAR; dSP; dATARGET; tryAMAGICbin(lshift,opASSIGN);
\&    {
\&      const IV shift = POPi;
\&      if (PL_op\->op_private & HINT_INTEGER) {
\&        const IV i = TOPi;
\&        SETi(i << shift);
\&      }
\&      else {
\&        const UV u = TOPu;
\&        SETu(u << shift);
\&      }
\&      RETURN;
\&    }
\&  }
.Ve
.PP
The first \s-1IV\s0 arg is pop'ed from the stack, the second arg is left on the stack (\f(CW\*(C`TOPi\*(C'\fR/\f(CW\*(C`TOPu\*(C'\fR),
because it is used as the return value. (\fITodo: explain the opASSIGN magic check.\fR)
One \s-1IV\s0 or \s-1UV\s0 is produced, dependent on \f(CW\*(C`HINT_INTEGER\*(C'\fR, set by the \f(CW\*(C`use integer\*(C'\fR pragma.
So it has a special signed/unsigned integer behaviour, which is not defined in the opcode 
declaration, because the \s-1API\s0 is indifferent on this, and it is also independent on the 
argument type. The result, if \s-1IV\s0 or \s-1UV,\s0 is entirely context dependent at compile-time 
( \f(CW\*(C`use integer at BEGIN\*(C'\fR ) or run-time ( \f(CW\*(C`$^H |= 1\*(C'\fR ), and only stored in the op.
.PP
What is left is the \f(CW\*(C`T\*(C'\fR flag, \*(L"target can be a pad\*(R". This is a useful optimization technique.
.PP
This is checked in the macro \f(CW\*(C`dATARGET\*(C'\fR
  \f(CW\*(C`SV *targ = (PL_op\-\*(C'\fRop_flags & OPf_STACKED ? sp[\-1] : \s-1PAD_SV\s0(PL_op\->op_targ));>
\&\f(CW\*(C`OPf_STACKED\*(C'\fR means \*(L"Some arg is arriving on the stack.\*(R" (see \fIop.h\fR)
So this reads, if the op contains \f(CW\*(C`OPf_STACKED\*(C'\fR, the magic \f(CW\*(C`targ\*(C'\fR (\*(L"target argument\*(R") 
is simply on the stack, but if not, the \f(CW\*(C`op_targ\*(C'\fR points to a \s-1SV\s0 on a private scratchpad. 
\&\*(L"target can be a pad\*(R", voila.
For reference see \*(L"Putting a C value on Perl stack\*(R" in perlguts.
.SS "Check Functions"
.IX Subsection "Check Functions"
They are defined in \fIop.c\fR and not in \fIpp.c\fR, because they belong tightly to the 
ops and newOP definition, and not to the actual pp_ opcode. That's why 
the actual \fIop.c\fR file is bigger than \fIpp.c\fR where the real gore for each op begins.
The name of each op's check function is defined in \fIopcodes.pl\fR, as shown above.
.PP
The \f(CW\*(C`ck_null\*(C'\fR check function is the most common.
.PP
.Vb 2
\&  $ perl \-F"/\ecI+/" \-ane \*(Aqprint $F[2],"\en" if $F[2] =~ /ck_null/\*(Aq opcode.pl|wc \-l
\&  128
.Ve
.PP
But we do have a lot of those check functions.
.PP
.Vb 2
\&  $ perl \-F"/\ecI+/" \-ane \*(Aqprint $F[2],"\en" if $F[2] =~ /ck_/\*(Aq opcode.pl|sort \-u|wc \-l
\&  43
.Ve
.PP
\&\fBWhen are they called, how do they look like, what do they do.\fR
.PP
The macro \s-1CHECKOP\s0(type,o) used to call the ck_ function has a little bit of 
common logic.
.PP
.Vb 6
\&  #define CHECKOP(type,o) \e
\&    ((PL_op_mask && PL_op_mask[type])                           \e
\&     ? ( op_free((OP*)o),                                       \e
\&         Perl_croak(aTHX_ "\*(Aq%s\*(Aq trapped by operation mask", PL_op_desc[type]),  \e
\&         (OP*)0 )                                               \e
\&     : CALL_FPTR(PL_check[type])(aTHX_ (OP*)o))
.Ve
.PP
So when a global \fBPL_op_mask\fR is fitting to the type the \s-1OP\s0 is nullified at once.
If not, the type specific check function with the help of \fIopcodes.pl\fR generating 
the \f(CW\*(C`PL_check\*(C'\fR array in \fIopnames.h\fR is called.
.SS "Constant Folding"
.IX Subsection "Constant Folding"
In theory pretty easy. If all op's arguments in a sequence are constant and the
op is sideffect free (\*(L"purely functional\*(R"), replace the op sequence with an
constant op as result.
.PP
We do it like this: We define the \f(CW\*(C`f\*(C'\fR flag in \fIopcodes.pl\fR, which tells the
compiler in the first pass to call \f(CW\*(C`fold_constants()\*(C'\fR on this op. See
\&\*(L"Compile pass 1: check routines and constant folding\*(R" above.  If all args are
constant, the result is constant also and the op sequence will be replaced by
the constant.
.PP
But take care, every \f(CW\*(C`f\*(C'\fR op must be sideeffect free.
.PP
E.g. our \f(CW\*(C`newUNOP()\*(C'\fR calls at the end:
.PP
.Vb 1
\&    return fold_constants((OP *) unop);
.Ve
.PP
\&\s-1OA_FOLDCONST ...\s0
.SS "Lexical Pragmas"
.IX Subsection "Lexical Pragmas"
To implement user lexical pragmas, there needs to be a way at run time to get
the compile time state of `%^H` for that block.  Storing `%^H` in every
block (or even \s-1COP\s0) would be very expensive, so a different approach is
taken.  The (running) state of \f(CW\*(C`%^H\*(C'\fR is serialised into a tree of HE-like
structs.  Stores into \f(CW\*(C`%^H\*(C'\fR are chained onto the current leaf as a struct
refcounted_he * with the key and the value.  Deletes from \f(CW\*(C`%^H\*(C'\fR are saved
with a value of \f(CW\*(C`PL_sv_placeholder\*(C'\fR.  The state of \f(CW\*(C`%^H\*(C'\fR at any point can be
turned back into a regular \s-1HV\s0 by walking back up the tree from that point's
leaf, ignoring any key you've already seen (placeholder or not), storing
the rest into the \s-1HV\s0 structure, then removing the placeholders. Hence
memory is only used to store the \f(CW\*(C`%^H\*(C'\fR deltas from the enclosing \s-1COP,\s0 rather
than the entire \f(CW\*(C`%^H\*(C'\fR on each \s-1COP.\s0
.PP
To cause actions on \f(CW\*(C`%^H\*(C'\fR to write out the serialisation records, it has
magic type 'H'. This magic (itself) does nothing, but its presence causes
the values to gain magic type 'h', which has entries for set and clear.
\&\f(CW\*(C`Perl_magic_sethint\*(C'\fR updates \f(CW\*(C`PL_compiling.cop_hints_hash\*(C'\fR with a store
record, with deletes written by \f(CW\*(C`Perl_magic_clearhint\*(C'\fR. \f(CW\*(C`SAVEHINTS\*(C'\fR
saves the current \f(CW\*(C`PL_compiling.cop_hints_hash\*(C'\fR on the save stack, so that
it will be correctly restored when any inner compiling scope is exited.
.SH "Examples"
.IX Header "Examples"
.SS "Call a subroutine"
.IX Subsection "Call a subroutine"
subname(args...) =>
.PP
.Vb 4
\&  pushmark
\&    args ...
\&  gv => subname
\&  entersub
.Ve
.SS "Call a method"
.IX Subsection "Call a method"
Here we have several combinations to define the package and the method name, either
compile-time (static as constant string), or dynamic as \fB\s-1GV\s0\fR (for the method name) or 
\&\fB\s-1PADSV\s0\fR (package name).
.PP
\&\fBmethod_named\fR holds the method name as \f(CW\*(C`sv\*(C'\fR if known at compile time.
If not \fBgv\fR (of the name) and \fBmethod\fR is used.
The package name is at the top of the stack.
A call stack is added with \fBpushmark\fR.
.PP
1. Static compile time package (\*(L"class\*(R") and method:
.PP
Class\->subname(args...) =>
.PP
.Vb 5
\&  pushmark
\&  const => PV "Class"
\&    args ...
\&  method_named => PV "subname"
\&  entersub
.Ve
.PP
2. Run-time package (\*(L"object\*(R") and compile-time method:
.PP
\&\f(CW$obj\fR\->meth(args...) =>
.PP
.Vb 5
\&  pushmark
\&  padsv => GV *packagename
\&    args ...
\&  method_named => PV "meth"
\&  entersub
.Ve
.PP
3. Run-time package and run-time method:
.PP
\&\f(CW$obj\fR\->$meth(args...) =>
.PP
.Vb 6
\&  pushmark
\&  padsv => GV *packagename
\&    args ...
\&  gvsv => GV *meth
\&  method
\&  entersub
.Ve
.PP
4. Compile-time package (\*(L"class\*(R") and run-time method:
.PP
Class\->$meth(args...) =>
.PP
.Vb 6
\&  pushmark
\&  const => PV "Class"
\&    args ...
\&  gvsv => GV *meth
\&  method
\&  entersub
.Ve
.SH "Hooks"
.IX Header "Hooks"
.SS "Special execution blocks \s-1BEGIN, CHECK, UNITCHECK, INIT, END\s0"
.IX Subsection "Special execution blocks BEGIN, CHECK, UNITCHECK, INIT, END"
Perl keeps special arrays of subroutines that are executed at the
beginning and at the end of a running Perl program and its program
units. These subroutines correspond to the special code blocks:
\&\f(CW\*(C`BEGIN\*(C'\fR, \f(CW\*(C`CHECK\*(C'\fR, \f(CW\*(C`UNITCHECK\*(C'\fR, \f(CW\*(C`INIT\*(C'\fR and \f(CW\*(C`END\*(C'\fR. (See basics at
\&\*(L"basics\*(R" in perlmod.)
.PP
Such arrays belong to Perl's internals that you're not supposed to
see. Entries in these arrays get consumed by the interpreter as it
enters distinct compilation phases, triggered by statements like
\&\f(CW\*(C`require\*(C'\fR, \f(CW\*(C`use\*(C'\fR, \f(CW\*(C`do\*(C'\fR, \f(CW\*(C`eval\*(C'\fR, etc.  To play as safest as
possible, the only allowed operations are to add entries to the start
and to the end of these arrays.
.PP
\&\s-1BEGIN, UNITCHECK\s0 and \s-1INIT\s0 are \s-1FIFO\s0 (first-in, first-out) blocks while
\&\s-1CHECK\s0 and \s-1END\s0 are \s-1LIFO\s0 (last-in, first-out).
.PP
Devel::Hook allows adding code the start or end of these
blocks. Manip::END even tries to remove certain entries.
.PP
\fIThe \s-1BEGIN\s0 block\fR
.IX Subsection "The BEGIN block"
.PP
A special array of code at \f(CW\*(C`PL_beginav\*(C'\fR, that is executed before
\&\f(CW\*(C`main_start\*(C'\fR, the first op, which is defined be called \f(CW\*(C`ENTER\*(C'\fR.
E.g. \f(CW\*(C`use module;\*(C'\fR adds its require and importer code into the \s-1BEGIN\s0
block.
.PP
\fIThe \s-1CHECK\s0 block\fR
.IX Subsection "The CHECK block"
.PP
The B compiler starting block at \f(CW\*(C`PL_checkav\*(C'\fR. This hooks int the
check function which is executed for every op created in bottom-up,
basic order.
.PP
\fIThe \s-1UNITCHECK\s0 block\fR
.IX Subsection "The UNITCHECK block"
.PP
A new block since Perl 5.10 at \f(CW\*(C`PL_unitcheckav\*(C'\fR runs right after the
\&\s-1CHECK\s0 block, to seperate possible B compilation hooks from other
checks.
.PP
\fIThe \s-1INIT\s0 block\fR
.IX Subsection "The INIT block"
.PP
At \f(CW\*(C`PL_initav\*(C'\fR.
.PP
\fIThe \s-1END\s0 block\fR
.IX Subsection "The END block"
.PP
At \f(CW\*(C`PL_endav\*(C'\fR.
.PP
Manip::END started to mess around with this block.
.PP
The array contains an \f(CW\*(C`undef\*(C'\fR for each block that has been
encountered. It's not really an \f(CW\*(C`undef\*(C'\fR though, it's a kind of raw
coderef that's not wrapped in a scalar ref. This leads to funky error
messages like \f(CW\*(C`Bizarre copy of CODE in sassign\*(C'\fR when you try to assign
one of these values to another variable. See Manip::END how to
manipulate these values array.
.SS "B and O module. The perl compiler."
.IX Subsection "B and O module. The perl compiler."
Malcom Beattie's B modules hooked into the early op tree stages to
represent the internal ops as perl objects and added the perl compiler
backends. See B and perlcompile.
.PP
The three main compiler backends are still \fBBytecode\fR, \fBC\fR and \fB\s-1CC\s0\fR.
.PP
\&\fITodo: Describe B's object representation a little bit deeper, its
\&\s-1CHECK\s0 hook, its internal transformers for Bytecode (asm and vars) and
C (the sections).\fR
.SS "\s-1MAD\s0"
.IX Subsection "MAD"
\&\s-1MAD\s0 stands for \*(L"Misc Attributed Data\*(R".
.PP
Larry Wall worked on a new \s-1MAD\s0 compiler backend outside of the B
approach, dumping the internal op tree representation as \fB\s-1XML\s0\fR or
\&\fB\s-1YAML\s0\fR, not as tree of perl B objects.
.PP
The idea is that all the information needed to recreate the original source is
stored in the op tree. To do this the tokens for the ops are associated with ops,
these madprops are a list of key-value pairs, where the key is a character as
listed at the end of \fIop.h\fR, the value normally is a string, but it might also be
a op, as in the case of a optimized op ('O'). Special for the whitespace key '_'
(whitespace before) and '#' (whitespace after), which indicate the whitespace or
comment before/after the previous key-value pair.
.PP
Also when things normally compiled out, like a \s-1BEGIN\s0 block, which normally do
not results in any ops, instead create a \s-1NULLOP\s0 with madprops used to recreate
the object.
.PP
\&\fIIs there any documentation on this?\fR
.PP
Why this awful \s-1XML\s0 and not the rich tree of perl objects?
.PP
Well there's an advantage.
The \s-1MAD XML\s0 can be seen as some kind of \s-1XML\s0 Storable/Freeze of the B
op tree, and can be therefore converted outside of the \s-1CHECK\s0 block,
which means you can easier debug the conversion (= compilation)
process. To debug the \s-1CHECK\s0 block in the B backends you have to 
use the B::Debugger \fBOd\fR or \fBOd_o\fR modules, which defer the 
\&\s-1CHECK\s0 to \s-1INIT.\s0 Debugging the highly recursive data is not easy, 
and often problems can not be reproduced in the B debugger because 
the B debugger influences the optree.
.PP
\&\fBkurila\fR <http://search.cpan.org/dist/kurila/> uses \s-1MAD\s0 to convert
Perl 5 source to the kurila dialect.
.PP
To convert a file 'source.pm' from Perl 5.10 to Kurila you need to do:
.PP
.Vb 7
\&  kurilapath=/usr/src/perl/kurila\-1.9
\&  bleadpath=/usr/src/perl/blead
\&  cd $kurilapath
\&  madfrom=\*(Aqperl\-5.10\*(Aq madto=\*(Aqkurila\-1.9\*(Aq \e
\&    madconvert="/usr/bin/perl $kurilapath/mad/p5kurila.pl" \e
\&    madpath="$bleadpath/mad" \e
\&    mad/convert /path/to/source.pm
.Ve
.PP
\&\fB\s-1PPI\s0\fR <http://search.cpan.org/dist/PPI/>, a Perl 5 source level parser not
related to the op tree at all, could also have been used for that.
.SS "Pluggable runops"
.IX Subsection "Pluggable runops"
The compile tree is executed by one of two existing runops functions, in \fIrun.c\fR
or in \fIdump.c\fR. \f(CW\*(C`Perl_runops_debug\*(C'\fR is used with \f(CW\*(C`DEBUGGING\*(C'\fR and the faster
\&\f(CW\*(C`Perl_runops_standard\*(C'\fR is used otherwise (See below in \*(L"Walkers\*(R"). For fine
control over the execution of the compile tree it is possible to provide your
own runops function.
.PP
It's probably best to copy one of the existing runops functions and
change it to suit your needs. Then, in the \f(CW\*(C`BOOT\*(C'\fR section of your \s-1XS\s0
file, add the line:
.PP
.Vb 1
\&  PL_runops = my_runops;
.Ve
.PP
This function should be as efficient as possible to keep your programs
running as fast as possible. See Jit for an even faster just-in-time 
compilation runloop.
.PP
\fIWalkers or runops\fR
.IX Subsection "Walkers or runops"
.PP
The standard op tree \fBwalker\fR or \fBrunops\fR is as simple as this fast
\&\f(CW\*(C`Perl_runops_standard()\*(C'\fR in (\fIrun.c\fR). It starts with \f(CW\*(C`main_start\*(C'\fR and walks
the \f(CW\*(C`op_next\*(C'\fR chain until the end. No need to check other fields, strictly
linear through the tree.
.PP
.Vb 10
\&  int
\&  Perl_runops_standard(pTHX)
\&  {
\&        dVAR;
\&        while ((PL_op = CALL_FPTR(PL_op\->op_ppaddr)(aTHX))) {
\&                PERL_ASYNC_CHECK(); /* until 5.13.2 */
\&        }
\&        TAINT_NOT;
\&        return 0;
\&  }
.Ve
.PP
To inspect the op tree within a perl program, you can also hook \f(CW\*(C`PL_runops\*(C'\fR (see
above at \*(L"Pluggable runops\*(R") to your own perl walker (see e.g. B::Utils
for various useful walkers), but you cannot modify the tree from within the B
accessors, only via \s-1XS.\s0 Or via B::Generate as explained in Simon Cozen's 
\&\*(L"Hacking the Optree for Fun...\*(R" <http://www.perl.com/pub/a/2002/05/07/optree.html>.
.PP
\&\fITodo: Show the other runloops, and esp. the B:Utils ones.\fR
\&\fITodo: Describe the dumper, the debugging and more extended walkers.\fR
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.SS "Internal and external modifications"
.IX Subsection "Internal and external modifications"
See the short description of the internal optimizer in the \*(L"Brief Summary\*(R".
.PP
\&\fITodo: Describe the exported variables and functions which can be
hooked, besides simply adding code to the blocks.\fR
.PP
Via \*(L"Pluggable runops\*(R" you can provide your own walker function, as it
is done in most B modules. Best see B::Utils.
.PP
You may also create custom ops at runtime (well, strictly speaking at
compile-time) via B::Generate.
.SS "Modules"
.IX Subsection "Modules"
The most important op tree module is B::Concise by Stephen McCamant.
.PP
B::Utils provides abstract-enough op tree grep's and walkers with
callbacks from the perl level.
.PP
Devel::Hook allows adding perl hooks into the \s-1BEGIN, CHECK,
UNITCHECK, INIT\s0 blocks.
.PP
Devel::TypeCheck tries to verify possible static typing for
expressions and variables, a pretty hard problem for compilers,
esp. with such dynamic and untyped variables as Perl 5.
.PP
Reini Urban maintains the interactive op tree debugger B::Debugger, 
the Compiler suite (B::C, B::CC, B::Bytecode), B::Generate and 
is working on Jit.
.SS "Various Articles"
.IX Subsection "Various Articles"
The best source of information is the source. It is very well documented.
.PP
There are some pod files from talks and workshops in \fIramblings/\fR.
From \s-1YAPC EU 2010\s0 there is a good screencast at <http://vimeo.com/14058377>.
.PP
Simon Cozens has posted the course material to NetThink's
<http://books.simon\-cozens.org/index.php/Perl_5_Internals#The_Lexer_and_the_Parser>
training course. This is the currently best available description on
that subject.
.PP
\&\*(L"Hacking the Optree for Fun...\*(R" at
<http://www.perl.com/pub/a/2002/05/07/optree.html> is the next step by
Simon Cozens.
.PP
Scott Walters added more details at <http://perldesignpatterns.com/?PerlAssembly>
.PP
Joshua ben Jore wrote a 50 minute presentation on \*(L"Perl 5
\&\s-1VM\s0 guts\*(R" at <http://diotalevi.isa\-geek.net/~josh/Presentations/Perl%205%20VM/>
focusing on the op tree for \s-1SPUG,\s0 the Seattle Perl User's Group.
.PP
Eric Wilhelm wrote a brief tour through the perl compiler backends for
the impatient refactorerer. The perl_guts_tour as mp3
<http://scratchcomputing.com/developers/perl_guts_tour.html> or as
pdf <http://scratchcomputing.com/developers/perl_guts_tour.pdf>
.PP
This text was created in this wiki article:
<http://www.perlfoundation.org/perl5/index.cgi?optree_guts>
The with B::C released version should be more actual.
.SH "Conclusion"
.IX Header "Conclusion"
So this is about 30% of the basic op tree information so far. Not speaking about
the guts. Simon Cozens and Scott Walters have more 30%, in the source are more
10% to copy&paste, and in the compilers and run-time information is the rest. I
hope with the help of some hackers we'll get it done, so that some people will
begin poking around in the B backends. And write the wonderful new \f(CW\*(C`dump\*(C'\fR/\f(CW\*(C`undump\*(C'\fR
functionality (which actually worked in the early years on Solaris) to
save-image and load-image at runtime as in \s-1LISP,\s0 analyse and optimize the
output, output \s-1PIR\s0 (parrot code), emit \s-1LLVM\s0 or another \s-1JIT\s0 optimized code or
even write assemblers. I have a simple one at home. :)
.PP
Written 2008 on the perl5 wiki with socialtext and pod in parallel 
by Reini Urban, \s-1CPAN ID\s0 \f(CW\*(C`rurban\*(C'\fR.
