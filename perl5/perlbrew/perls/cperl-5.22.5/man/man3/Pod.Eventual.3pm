.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Pod::Eventual 3"
.TH Pod::Eventual 3 "2013-11-06" "perl v5.22.5" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Eventual \- read a POD document as a series of trivial events
.SH "VERSION"
.IX Header "VERSION"
version 0.094001
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Your::Pod::Parser;
\&  use base \*(AqPod::Eventual\*(Aq;
\&
\&  sub handle_event {
\&    my ($self, $event) = @_;
\&
\&    print Dumper($event);
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1POD\s0 is a pretty simple format to write, but it can be a big pain to deal with
reading it and doing anything useful with it.  Most existing \s-1POD\s0 parsers care
about semantics, like whether a \f(CW\*(C`=item\*(C'\fR occurred after an \f(CW\*(C`=over\*(C'\fR but before
a \f(CW\*(C`back\*(C'\fR, figuring out how to link a \f(CW\*(C`L<>\*(C'\fR, and other things like
that.
.PP
Pod::Eventual is much less ambitious and much more stupid.  Fortunately, stupid
is often better.  (That's what I keep telling myself, anyway.)
.PP
Pod::Eventual reads line-based input and produces events describing each \s-1POD\s0
paragraph or directive it finds.  Once complete events are immediately passed
to the \f(CW\*(C`handle_event\*(C'\fR method.  This method should be implemented by
Pod::Eventual subclasses.  If it isn't, Pod::Eventual's own \f(CW\*(C`handle_event\*(C'\fR
will be called, and will raise an exception.
.SH "METHODS"
.IX Header "METHODS"
.SS "read_handle"
.IX Subsection "read_handle"
.Vb 1
\&  Pod::Eventual\->read_handle($io_handle, \e%arg);
.Ve
.PP
This method iterates through the lines of a handle, producing events and
calling the \f(CW\*(C`handle_event\*(C'\fR method.
.PP
The only valid argument in \f(CW%arg\fR (for now) is \f(CW\*(C`in_pod\*(C'\fR, which indicates
whether we should assume that we are parsing pod when we start parsing the
file.  By default, this is false.
.PP
This is useful to behave differently when reading a \fI.pm\fR or \fI.pod\fR file.
.PP
\&\fBImportant:\fR the handle is expected to have an encoding layer so that it will
return text, not bytes, on reads.
.SS "read_file"
.IX Subsection "read_file"
This behaves just like \f(CW\*(C`read_handle\*(C'\fR, but expects a filename rather than a
handle.  The file will be assumed to be \s-1UTF\-8\s0 encoded.
.SS "read_string"
.IX Subsection "read_string"
This behaves just like \f(CW\*(C`read_handle\*(C'\fR, but expects a string containing \s-1POD\s0
text rather than a handle.
.SS "handle_event"
.IX Subsection "handle_event"
This method is called each time Pod::Evental finishes scanning for a new \s-1POD\s0
event.  It must be implemented by a subclass or it will raise an exception.
.SS "handle_nonpod"
.IX Subsection "handle_nonpod"
This method is called each time a non-POD segment is seen \*(-- that is, lines
after \f(CW\*(C`=cut\*(C'\fR and before another command.
.PP
If unimplemented by a subclass, it does nothing by default.
.SS "handle_blank"
.IX Subsection "handle_blank"
This method is called at the end of a sequence of one or more blank lines.
.PP
If unimplemented by a subclass, it does nothing by default.
.SH "EVENTS"
.IX Header "EVENTS"
There are four kinds of events that Pod::Eventual will produce.  All are
represented as hash references.
.SS "Command Events"
.IX Subsection "Command Events"
These events represent commands \*(-- those things that start with an equals sign
in the first column.  Here are some examples of \s-1POD\s0 and the event that would be
produced.
.PP
A simple header:
.PP
.Vb 1
\&  =head1 NAME
\&
\&  { type => \*(Aqcommand\*(Aq, command => \*(Aqhead1\*(Aq, content => "NAME\en", start_line => 4 }
.Ve
.PP
Notice that the content includes the trailing newline.  That's to maintain
similarity with this possibly-surprising case:
.PP
.Vb 2
\&  =for HTML
\&  We\*(Aqre actually still in the command event, here.
\&
\&  {
\&    type    => \*(Aqcommand\*(Aq,
\&    command => \*(Aqfor\*(Aq,
\&    content => "HTML\enWe\*(Aqre actually still in the command event, here.\en",
\&    start_line => 8,
\&  }
.Ve
.PP
Pod::Eventual does not care what the command is.  It doesn't keep track of what
it's seen or whether you've used a command that isn't defined.  The only
special case is \f(CW\*(C`=cut\*(C'\fR, which is never more than one line.
.PP
.Vb 2
\&  =cut
\&  We are no longer parsing POD when this line is read.
\&
\&  {
\&    type    => \*(Aqcommand\*(Aq,
\&    command => \*(Aqcut\*(Aq,
\&    content => "\en",
\&    start_line => 15,
\&  }
.Ve
.PP
Waiving this special case may be an option in the future.
.SS "Text Events"
.IX Subsection "Text Events"
A text event is just a paragraph of text, beginning after one or more empty
lines and running until the next empty line (or \fI=cut\fR).  In Perl 5's standard
usage of Pod, text content that begins with whitespace is a \*(L"verbatim\*(R"
paragraph, and text content that begins with non-whitespace is an \*(L"ordinary\*(R"
paragraph.
.PP
Pod::Eventual doesn't care.
.PP
Text events look like this:
.PP
.Vb 5
\&  {
\&    type    => \*(Aqtext\*(Aq,
\&    content => "a string of text ending with a\en",
\&    start_line =>  16,
\&  }
.Ve
.SS "Blank events"
.IX Subsection "Blank events"
These events represent blank lines (or many blank lines) within a Pod section.
.PP
Blank events look like this:
.PP
.Vb 5
\&  {
\&    type    => \*(Aqblank\*(Aq,
\&    content => "\en\en\en\en",
\&    start_line => 21,
\&  }
.Ve
.SS "Non-Pod events"
.IX Subsection "Non-Pod events"
These events represent non-Pod segments of the input.
.PP
Non-Pod events look like this:
.PP
.Vb 5
\&  {
\&    type    => \*(Aqnonpod\*(Aq,
\&    content => "#!/usr/bin/perl\enuse strict;\en\enuse Acme::ProgressBar\en\en",
\&    start_line => 1,
\&  }
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Ricardo \s-1SIGNES\s0 <rjbs@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2013 by Ricardo \s-1SIGNES.\s0
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
