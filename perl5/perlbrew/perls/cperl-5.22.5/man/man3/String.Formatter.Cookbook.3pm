.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "String::Formatter::Cookbook 3"
.TH String::Formatter::Cookbook 3 "2013-11-09" "perl v5.22.5" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
String::Formatter::Cookbook \- ways to put String::Formatter to use
.SH "VERSION"
.IX Header "VERSION"
version 0.102084
.SH "OVERVIEW"
.IX Header "OVERVIEW"
String::Formatter is a pretty simple system for building formatting routines,
but it can be hard to get started without an idea of the sort of things that
are possible.
.SH "BASIC RECIPES"
.IX Header "BASIC RECIPES"
.SS "constants only"
.IX Subsection "constants only"
The simplest stringf interface you can provide is one that just formats
constant strings, allowing the user to put them inside other fixed strings with
alignment:
.PP
.Vb 8
\&  use String::Formatter stringf => {
\&    input_processor => \*(Aqforbid_input\*(Aq,
\&    codes => {
\&      a => \*(Aqapples\*(Aq,
\&      b => \*(Aqbananas\*(Aq,
\&      w => \*(Aqwatermelon\*(Aq,
\&    },
\&  };
\&
\&  print stringf(\*(AqI eat %a and %b but never %w.\*(Aq);
\&
\&  # Output:
\&  # I eat apples and bananas but never watermelon.
.Ve
.PP
If the user tries to parameterize the string by passing arguments after the
format string, an exception will be raised.
.SS "sprintf-like conversions"
.IX Subsection "sprintf-like conversions"
Another common pattern is to create a routine that behaves like Perl's
\&\f(CW\*(C`sprintf\*(C'\fR, but with a different set of conversion routines.  (It will also
almost certainly have much simpler semantics than Perl's wildly complex
behavior.)
.PP
.Vb 7
\&  use String::Formatter stringf => {
\&    codes => {
\&      s => sub { $_ },     # string itself
\&      l => sub { length }, # length of input string
\&      e => sub { /[^\ex00\-\ex7F]/ ? \*(Aq8bit\*(Aq : \*(Aq7bit\*(Aq }, # ascii\-safeness
\&    },
\&  };
\&
\&  print stringf(
\&    "My name is %s.  I am about %l feet tall.  I use an %e alphabet.\en",
\&    \*(AqRicardo\*(Aq,
\&    \*(Aqffffff\*(Aq,
\&    \*(AqabcchdefghijklllmnÃ±opqrrrstuvwxyz\*(Aq,
\&  );
\&
\&  # Output:
\&  # My name is Ricardo.  I am about 6 feet tall.  I use an 8bit alphabet.
.Ve
.PP
\&\fBWarning\fR: The behavior of positional string replacement when the conversion
codes mix constant strings and code references is currently poorly nailed-down.
Do not rely on it yet.
.SS "named conversions"
.IX Subsection "named conversions"
This recipe acts a bit like Python's format operator when given a dictionary.
Rather than matching format code position with input ordering, inputs can be
chosen by name.
.PP
.Vb 3
\&  use String::Formatter stringf => {
\&    input_processor => \*(Aqrequire_named_input\*(Aq,
\&    string_replacer => \*(Aqnamed_replace\*(Aq,
\&
\&    codes => {
\&      s => sub { $_ },     # string itself
\&      l => sub { length }, # length of input string
\&      e => sub { /[^\ex00\-\ex7F]/ ? \*(Aq8bit\*(Aq : \*(Aq7bit\*(Aq }, # ascii\-safeness
\&    },
\&  };
\&
\&  print stringf(
\&    "My %{which}s name is %{name}s.  My name is %{name}l letters long.",
\&    {
\&      which => \*(Aqfirst\*(Aq,
\&      name  => \*(AqMarvin\*(Aq,
\&    },
\&  );
\&
\&  # Output:
\&  # My first name is Marvin.  My name is 6 letters long.
.Ve
.PP
Because this is a useful recipe, there is a shorthand for it:
.PP
.Vb 7
\&  use String::Formatter named_stringf => {
\&    codes => {
\&      s => sub { $_ },     # string itself
\&      l => sub { length }, # length of input string
\&      e => sub { /[^\ex00\-\ex7F]/ ? \*(Aq8bit\*(Aq : \*(Aq7bit\*(Aq }, # ascii\-safeness
\&    },
\&  };
.Ve
.SS "method calls"
.IX Subsection "method calls"
Some objects provide methods to stringify them flexibly.  For example, many
objects that represent timestamps allow you to call \f(CW\*(C`strftime\*(C'\fR or something
similar.  The \f(CW\*(C`method_replace\*(C'\fR string replacer comes in handy here:
.PP
.Vb 3
\&  use String::Formatter stringf => {
\&    input_processor => \*(Aqrequire_single_input\*(Aq,
\&    string_replacer => \*(Aqmethod_replace\*(Aq,
\&
\&    codes => {
\&      f => \*(Aqstrftime\*(Aq,
\&      c => \*(Aqformat_cldr\*(Aq,
\&      s => sub { "$_[0]" },
\&    },
\&  };
\&
\&  print stringf(
\&    "%{%Y\-%m\-%d}f is also %{yyyy\-MM\-dd}c.  Default string is %s.",
\&    DateTime\->now,
\&  );
\&
\&  # Output:
\&  # 2009\-11\-17 is also 2009\-11\-17.  Default string is 2009\-11\-17T15:35:11.
.Ve
.PP
This recipe is available as the export \f(CW\*(C`method_stringf\*(C'\fR:
.PP
.Vb 7
\&  use String::Formatter method_stringf => {
\&    codes => {
\&      f => \*(Aqstrftime\*(Aq,
\&      c => \*(Aqformat_cldr\*(Aq,
\&      s => sub { "$_[0]" },
\&    },
\&  };
.Ve
.PP
You can easily use this to implement an actual stringf-like method:
.PP
.Vb 1
\&  package MyClass;
\&
\&  use String::Formatter method_stringf => {
\&    \-as => \*(Aq_stringf\*(Aq,
\&    codes => {
\&      f => \*(Aqstrftime\*(Aq,
\&      c => \*(Aqformat_cldr\*(Aq,
\&      s => sub { "$_[0]" },
\&    },
\&  };
\&
\&  sub format {
\&    my ($self, $format) = @_;
\&    return _stringf($format, $self);
\&  }
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Ricardo Signes <rjbs@cpan.org>
.IP "\(bu" 4
Darren Chamberlain <darren@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2013 by Ricardo Signes <rjbs@cpan.org>.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The GNU General Public License, Version 2, June 1991
.Ve
