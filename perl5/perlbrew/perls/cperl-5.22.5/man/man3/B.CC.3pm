.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::CC 3pm"
.TH B::CC 3pm "2018-01-01" "perl v5.22.5" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::CC \- Perl compiler's optimized C translation backend
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        perl \-MO=CC[,OPTIONS] foo.pl
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This compiler backend takes Perl source and generates C source code
corresponding to the flow of your program with unrolled ops and optimised
stack handling and lexicals variable types. In other words, this backend is
somewhat a \*(L"real\*(R" compiler in the sense that many people think about
compilers. Note however that, currently, it is a very poor compiler in that
although it generates (mostly, or at least sometimes) correct code, it
performs relatively few optimisations.  This will change as the compiler and
the types develops. The result is that running an executable compiled with
this backend may start up more quickly than running the original Perl program
(a feature shared by the \fBC\fR compiler backend\*(--see B::C) and may also
execute slightly faster. This is by no means a good optimising compiler\*(--yet.
.SH "OPTIONS"
.IX Header "OPTIONS"
If there are any non-option arguments, they are taken to be
names of objects to be saved (probably doesn't work properly yet).
Without extra arguments, it saves the main program.
.IP "\fB\-ofilename\fR" 4
.IX Item "-ofilename"
Output to filename instead of \s-1STDOUT\s0
.IP "\fB\-c\fR" 4
.IX Item "-c"
Check and abort.
.Sp
Compiles and prints only warnings, but does not emit C code.
.IP "\fB\-v\fR" 4
.IX Item "-v"
Verbose compilation (prints a few compilation stages).
.IP "\fB\-\-\fR" 4
.IX Item "--"
Force end of options
.IP "\fB\-uPackname\fR" 4
.IX Item "-uPackname"
Force apparently unused subs from package Packname to be compiled.
This allows programs to use eval \*(L"\fIfoo()\fR\*(R" even when sub foo is never
seen to be used at compile time. The down side is that any subs which
really are never used also have code generated. This option is
necessary, for example, if you have a signal handler foo which you
initialise with \f(CW\*(C`$SIG{BAR} = "foo"\*(C'\fR.  A better fix, though, is just
to change it to \f(CW\*(C`$SIG{BAR} = \e&foo\*(C'\fR. You can have multiple \fB\-u\fR
options. The compiler tries to figure out which packages may possibly
have subs in which need compiling but the current version doesn't do
it very well. In particular, it is confused by nested packages (i.e.
of the form \f(CW\*(C`A::B\*(C'\fR) where package \f(CW\*(C`A\*(C'\fR does not contain any subs.
.ie n .IP "\fB\-UPackname\fR  ""unuse"" skip Package" 4
.el .IP "\fB\-UPackname\fR  ``unuse'' skip Package" 4
.IX Item "-UPackname unuse skip Package"
Ignore all subs from Package to be compiled.
.Sp
Certain packages might not be needed at run-time, even if the pessimistic
walker detects it.
.IP "\fB\-mModulename\fR" 4
.IX Item "-mModulename"
Instead of generating source for a runnable executable, generate
source for an \s-1XSUB\s0 module. The boot_Modulename function (which
DynaLoader can look for) does the appropriate initialisation and runs
the main part of the Perl source that is being compiled.
.IP "\fB\-nInitname\fR" 4
.IX Item "-nInitname"
Provide a different init name for additional objects added via cmdline.
.IP "\fB\-strict\fR" 4
.IX Item "-strict"
With a \s-1DEBUGGING\s0 perl compile-time errors for range and flip without
compile-time context are only warnings.
With \f(CW\*(C`\-strict\*(C'\fR these warnings are fatal, otherwise only run-time errors occur.
.IP "\fB\-On\fR" 4
.IX Item "-On"
Optimisation level (n = 0, 1, 2). \fB\-O\fR means \fB\-O1\fR.
.Sp
The following B::C optimisations are applied automatically:
.Sp
optimize_warn_sv save_data_fh av\-init2|av_init save_sig destruct
pv_copy_on_grow
.Sp
\&\fB\-O1\fR sets \fB\-ffreetmps\-each\-bblock\fR.
.Sp
\&\fB\-O2\fR adds \fB\-ffreetmps\-each\-loop\fR, \f(CW\*(C`\-faelem\*(C'\fR and \fB\-fno\-destruct\fR from B::C.
.Sp
The following options must be set explicitly:
.Sp
.Vb 1
\&  B<\-fno\-taint> or B<\-fomit\-taint>,
\&
\&  B<\-fslow\-signals>,
\&
\&  B<\-no\-autovivify>,
\&
\&  B<\-fno\-magic>.
.Ve
.ie n .IP "\fB\-f\fR""OPTIM""" 4
.el .IP "\fB\-f\fR\f(CWOPTIM\fR" 4
.IX Item "-fOPTIM"
Force optimisations on or off one at a time.
Unknown optimizations are passed down to B::C.
.IP "\fB\-ffreetmps\-each\-bblock\fR" 4
.IX Item "-ffreetmps-each-bblock"
Delays \s-1FREETMPS\s0 from the end of each statement to the end of the each
basic block.
.Sp
Enabled with \fB\-O1\fR.
.IP "\fB\-ffreetmps\-each\-loop\fR" 4
.IX Item "-ffreetmps-each-loop"
Delays \s-1FREETMPS\s0 from the end of each statement to the end of the group
of basic blocks forming a loop. At most one of the freetmps\-each\-*
options can be used.
.Sp
Enabled with \fB\-O2\fR.
.IP "\fB\-faelem\fR" 4
.IX Item "-faelem"
Enable array element access optimizations, allowing unchecked
fast access under certain circumstances.
.Sp
Enabled with \fB\-O2\fR and not-threaded perls only.
.IP "\fB\-fno\-inline\-ops\fR" 4
.IX Item "-fno-inline-ops"
Do not inline calls to certain small pp ops.
.Sp
Most of the inlinable ops were already inlined.
Turns off inlining for some new ops.
.Sp
\&\s-1AUTOMATICALLY\s0 inlined:
.Sp
pp_null pp_stub pp_unstack pp_and pp_andassign pp_or pp_orassign pp_cond_expr
pp_padsv pp_const pp_nextstate pp_dbstate pp_rv2gv pp_sort pp_gv pp_gvsv
pp_aelemfast pp_ncmp pp_add pp_subtract pp_multiply pp_divide pp_modulo
pp_left_shift pp_right_shift pp_i_add pp_i_subtract pp_i_multiply pp_i_divide
pp_i_modulo pp_eq pp_ne pp_lt pp_gt pp_le pp_ge pp_i_eq pp_i_ne pp_i_lt
pp_i_gt pp_i_le pp_i_ge pp_scmp pp_slt pp_sgt pp_sle pp_sge pp_seq pp_sne
pp_sassign pp_preinc pp_pushmark pp_list pp_entersub pp_formline pp_goto
pp_enterwrite pp_leavesub pp_leavewrite pp_entergiven pp_leavegiven
pp_entereval pp_dofile pp_require pp_entertry pp_leavetry pp_grepstart
pp_mapstart pp_grepwhile pp_mapwhile pp_return pp_range pp_flip pp_flop
pp_enterloop pp_enteriter pp_leaveloop pp_next pp_redo pp_last pp_subst
pp_substcont
.Sp
\&\s-1DONE\s0 with \-finline\-ops:
.Sp
pp_enter pp_reset pp_regcreset pp_stringify
.Sp
\&\s-1TODO\s0 with \-finline\-ops:
.Sp
pp_anoncode pp_wantarray pp_srefgen pp_refgen pp_ref pp_trans pp_schop pp_chop
pp_schomp pp_chomp pp_not pp_sprintf pp_anonlist pp_shift pp_once pp_lock
pp_rcatline pp_close pp_time pp_alarm pp_av2arylen: no lvalue, pp_length: no
magic
.IP "\fB\-fomit\-taint\fR" 4
.IX Item "-fomit-taint"
Omits generating code for handling perl's tainting mechanism.
.IP "\fB\-fslow\-signals\fR" 4
.IX Item "-fslow-signals"
Add \s-1PERL_ASYNC_CHECK\s0 after every op as in the old Perl runloop before 5.13.
.Sp
perl \*(L"Safe signals\*(R" check the state of incoming signals after every op.
See <http://perldoc.perl.org/perlipc.html#Deferred\-Signals\-(Safe\-Signals)>
We trade safety for more speed and delay the execution of non-IO signals
(\s-1IO\s0 signals are already handled in PerlIO) from after every single Perl op
to the same ops as used in 5.14.
.Sp
Only with \-fslow\-signals we get the old slow and safe behaviour.
.IP "\fB\-fno\-name\-magic\fR" 4
.IX Item "-fno-name-magic"
With the default \f(CW\*(C`\-fname\-magic\*(C'\fR we infer the \s-1SCALAR\s0 type for specially named
locals vars and most ops use C vars then, not the perl vars.
Arithmetic and comparison is inlined. Scalar magic is bypassed.
.Sp
With \f(CW\*(C`\-fno\-name\-magic\*(C'\fR do not infer a local variable type from its name:
.Sp
.Vb 1
\&  B<_i> suffix for int, B<_d> for double/num, B<_ir> for register int
.Ve
.Sp
See the experimental \f(CW\*(C`\-ftype\-attr\*(C'\fR type attributes.
Currently supported are \fBint\fR and \fBnum\fR only. See </load_pad>.
.IP "\fB\-ftype\-attr\fR (\s-1DOES NOT WORK YET\s0)" 4
.IX Item "-ftype-attr (DOES NOT WORK YET)"
Experimentally support \fBtype attributes\fR for \fBint\fR and \fBnum\fR,
\&\s-1SCALAR\s0 only so far.
For most ops new C vars are used then, not the fat perl vars.
Very awkward to use until the basic type classes are supported from
within core or use types.
.Sp
Enabled with \fB\-O2\fR. See \s-1TYPES\s0 and </load_pad>.
.IP "\fB\-fno\-autovivify\fR" 4
.IX Item "-fno-autovivify"
Do not vivify array and soon also hash elements when accessing them.
Beware: Vivified elements default to undef, unvivified elements are
invalid.
.Sp
This is the same as the pragma \*(L"no autovivification\*(R" and allows
very fast array accesses, 4\-6 times faster, without the overhead of
autovivification.
.IP "\fB\-fno\-magic\fR" 4
.IX Item "-fno-magic"
Assume certain data being optimized is never tied or is holding other magic.
This mainly holds for arrays being optimized, but in the future hashes also.
.IP "\fB\-D\fR" 4
.IX Item "-D"
Debug options (concatenated or separate flags like \f(CW\*(C`perl \-D\*(C'\fR).
Verbose debugging options are crucial, because the interactive
debugger Od adds a lot of ballast to the resulting code.
.IP "\fB\-Dr\fR" 4
.IX Item "-Dr"
Writes debugging output to \s-1STDERR\s0 just as it's about to write to the
program's runtime (otherwise writes debugging info as comments in
its C output).
.IP "\fB\-DO\fR" 4
.IX Item "-DO"
Outputs each \s-1OP\s0 as it's compiled
.IP "\fB\-DT\fR" 4
.IX Item "-DT"
Outputs the contents of the \fBstack\fR at each \s-1OP.\s0
Values are B::Stackobj objects.
.IP "\fB\-Dc\fR" 4
.IX Item "-Dc"
Outputs the contents of the loop \fBcontext stack\fR, the \f(CW@cxstack\fR.
.IP "\fB\-Dw\fR" 4
.IX Item "-Dw"
Outputs the contents of the \fBshadow\fR stack at each \s-1OP.\s0
.IP "\fB\-Da\fR" 4
.IX Item "-Da"
Outputs the contents of the shadow pad of lexicals as it's loaded for
each sub or the main program.
.IP "\fB\-Dq\fR" 4
.IX Item "-Dq"
Outputs the name of each fake \s-1PP\s0 function in the queue as it's about
to process it.
.IP "\fB\-Dl\fR" 4
.IX Item "-Dl"
Output the filename and line number of each original line of Perl
code as it's processed (\f(CW\*(C`pp_nextstate\*(C'\fR).
.IP "\fB\-Dt\fR" 4
.IX Item "-Dt"
Outputs timing information of compilation stages.
.IP "\fB\-DF\fR" 4
.IX Item "-DF"
Add Flags info to the code.
.SH "NOTABLE FUNCTIONS"
.IX Header "NOTABLE FUNCTIONS"
.SS "cc_queue"
.IX Subsection "cc_queue"
Creates a new ccpp optree.
.PP
Initialised by saveoptree_callback in B::C, replaces B::C::walk_and_save_optree.
Called by every \f(CW\*(C`CV::save\*(C'\fR if \s-1ROOT.\s0
\&\fBblocksort\fR also creates its block closure with cc_queue.
.SH "save_or_restore_lexical_state"
.IX Header "save_or_restore_lexical_state"
The compiler tracks state of lexical variables in \f(CW@pad\fR to generate optimised
code. But multiple execution paths lead to the entry point of a basic block.
The state of the first execution path is saved and all other execution
paths are restored to the state of the first one.
.PP
Missing flags are regenerated by loading values.
.PP
Added flags must are removed; otherwise the compiler would be too optimistic,
hence generating code which doesn't match state of the other execution paths.
.SS "load_pad"
.IX Subsection "load_pad"
Load pad takes (the elements of) a \s-1PADLIST\s0 as arguments and loads up \f(CW@pad\fR
with Stackobj-derived objects which represent those lexicals.
.PP
If/when perl itself can generate type information \f(CW\*(C`(my int $foo; my $foo : int)\*(C'\fR then we'll
take advantage of that here. Until then, we'll use the \*(L"\-fno\-name\-magic\*(R" in \-fname\-magic
hack to tell the compiler when we want a lexical to be a particular type or to be a register.
.SS "label"
.IX Subsection "label"
We not only mark named labels in C as such \- with prefix \*(L"label_\*(R".
.PP
We also have to mark each known (back jumps) and yet unknown branch targets
(forward jumps) for compile-time generated branch points, with the \*(L"lab_\*(R"
prefix.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 2
\&        perl \-MO=CC,\-O2,\-ofoo.c foo.pl
\&        perl cc_harness \-o foo foo.c
.Ve
.PP
Note that \f(CW\*(C`cc_harness\*(C'\fR lives in the \f(CW\*(C`B\*(C'\fR subdirectory of your perl
library directory. The utility called \f(CW\*(C`perlcc\*(C'\fR may also be used to
help make use of this compiler.
.PP
.Vb 3
\&        # create a shared XS module
\&        perl \-MO=CC,\-mFoo,\-oFoo.c Foo.pm
\&        perl cc_harness \-shared \-c \-o Foo.so Foo.c
\&
\&        # side\-effects just for the types and attributes
\&        perl \-MB::CC \-e\*(Aqmy int $i:unsigned; ...\*(Aq
.Ve
.SH "TYPES"
.IX Header "TYPES"
Implemented type classes are \fBint\fR and \fBnum\fR.
Planned is \fBstr\fR also.
Implemented are only \s-1SCALAR\s0 types yet.
Typed arrays and hashes and perfect hashes need coretypes, types and
proper \f(CW\*(C`const\*(C'\fR support first.
.PP
Deprecated are inferred types via the names of locals, with '_i', '_d' suffix
and an optional 'r' suffix for register allocation.
.PP
.Vb 1
\&  C<my ($i_i, $j_ir, $num_d);>
.Ve
.PP
Planned type attributes are \fBint\fR, \fBnum\fR, \fBstr\fR, \fBunsigned\fR, \fBro\fR / \fBconst\fR.
.PP
The attributes are perl attributes, and \f(CW\*(C`int|num|str\*(C'\fR are either
compiler classes or hints for more allowed types.
.PP
.Vb 3
\&  C<my int $i :num;>  declares a NV with SVf_IOK. Same as C<my $i:int:double;>
\&  C<my int $i;>          declares an IV. Same as C<my $i:int;>
\&  C<my int $i :str;>  declares a PVIV. Same as C<my $i:int:string;>
\&
\&  C<my int @array :unsigned = (0..4);> will be used as c var in faster arithmetic and cmp.
\&                                       With :const or :ro even more.
\&  C<my str %hash :const
\&    = (foo => \*(Aqfoo\*(Aq, bar => \*(Aqbar\*(Aq);> declare string values,
\&                                     generate as read\-only perfect hash.
.Ve
.PP
\&\fB:unsigned\fR is valid for int only and declares an \s-1UV.\s0
.PP
\&\fB:register\fR denotes optionally a short and hot life-time.
.PP
\&\fB:temporary\fR are usually generated internally, nameless lexicals.
They are more aggressivly destroyed and ignored.
.PP
\&\fB:ro\fR or \fB:const\fR throw a compile-time error on write access and may optimize
the internal structure of the variable. We don't need to write back the variable
to perl (lexical write_back).
.PP
\&\s-1STATUS\s0
.PP
\&\s-1OK\s0 (classes only):
.PP
.Vb 2
\&  my int $i;
\&  my num $d;
.Ve
.PP
\&\s-1NOT YET OK\s0 (attributes):
.PP
.Vb 4
\&  my int $i :register;
\&  my $i :int;
\&  my $const :int:const;
\&  my $uv :int:unsigned;
.Ve
.PP
\&\s-1ISSUES\s0
.PP
This does not work with pure perl, unless you \f(CW\*(C`use B::CC\*(C'\fR or \f(CW\*(C`use types\*(C'\fR or
implement the classes and attribute type stubs in your code,
\&\f(CW\*(C`sub Mypkg::MODIFY_SCALAR_ATTRIBUTES {}\*(C'\fR and \f(CW\*(C`sub Mypkg::FETCH_SCALAR_ATTRIBUTES {}\*(C'\fR.
(\s-1TODO:\s0 empty should be enough to be detected by the compiler.)
.PP
Compiled code pulls in the magic \s-1MODIFY_SCALAR_ATTRIBUTES\s0 and \s-1FETCH_SCALAR_ATTRIBUTES\s0
functions, even if they are used at compile time only.
.PP
Using attributes adds an import block to your code.
.PP
Up until 5.20 only \fBour\fR variable attributes are checked at compile-time,
\&\fBmy\fR variables attributes at run-time only, which is too late for the compiler.
Perl attributes need to be fixed for types hints by adding \f(CW\*(C`CHECK_SCALAR_ATTRIBUTES\*(C'\fR.
.PP
\&\s-1FUTURE\s0
.PP
We should be able to support types on \s-1ARRAY\s0 and \s-1HASH.\s0
For arrays also sizes to omit bounds-checking.
.PP
.Vb 2
\&  my int @array; # array of ints, faster magic\-less access esp. in inlined arithmetic and cmp.
\&  my str @array : const = qw(foo bar);   # compile\-time error on write. no lexical write_back
\&
\&  my int $hash = {"1" => 1, "2" => 2};   # int values, type\-checked on write my
\&  str %hash1 : const = (foo => \*(Aqbar\*(Aq);   # string keys only => maybe gperf
\&                                         # compile\-time error on write
.Ve
.PP
Typed hash keys are always strings, as array keys are always int. Only the values are typed.
.PP
We should be also able to add type attributes for functions and methods,
i.e. for argument and return types. See types and
<http://blogs.perl.org/users/rurban/2011/02/use\-types.html>
.SH "BUGS"
.IX Header "BUGS"
Plenty. Current status: experimental.
.SH "DIFFERENCES"
.IX Header "DIFFERENCES"
These aren't really bugs but they are constructs which are heavily
tied to perl's compile-and-go implementation and with which this
compiler backend cannot cope.
.SS "Loops"
.IX Subsection "Loops"
Standard perl calculates the target of \*(L"next\*(R", \*(L"last\*(R", and \*(L"redo\*(R"
at run-time. The compiler calculates the targets at compile-time.
For example, the program
.PP
.Vb 5
\&    sub skip_on_odd { next NUMBER if $_[0] % 2 }
\&    NUMBER: for ($i = 0; $i < 5; $i++) {
\&        skip_on_odd($i);
\&        print $i;
\&    }
.Ve
.PP
produces the output
.PP
.Vb 1
\&    024
.Ve
.PP
with standard perl but calculates with the compiler the
goto label_NUMBER wrong, producing 01234.
.ie n .SS "Context of "".."""
.el .SS "Context of ``..''"
.IX Subsection "Context of .."
The context (scalar or array) of the \*(L"..\*(R" operator determines whether
it behaves as a range or a flip/flop. Standard perl delays until
runtime the decision of which context it is in but the compiler needs
to know the context at compile-time. For example,
.PP
.Vb 4
\&    @a = (4,6,1,0,0,1);
\&    sub range { (shift @a)..(shift @a) }
\&    print range();
\&    while (@a) { print scalar(range()) }
.Ve
.PP
generates the output
.PP
.Vb 1
\&    456123E0
.Ve
.PP
with standard Perl but gives a run-time warning with compiled Perl.
.PP
If the option \fB\-strict\fR is used it gives a compile-time error.
.SS "Arithmetic"
.IX Subsection "Arithmetic"
Compiled Perl programs use native C arithmetic much more frequently
than standard perl. Operations on large numbers or on boundary
cases may produce different behaviour.
In doubt B::CC code behaves more like with \f(CW\*(C`use integer\*(C'\fR.
.SS "Deprecated features"
.IX Subsection "Deprecated features"
Features of standard perl such as \f(CW$[\fR which have been deprecated
in standard perl since Perl5 was released have not been implemented
in the optimizing compiler.
.SH "AUTHORS"
.IX Header "AUTHORS"
Malcolm Beattie \f(CW\*(C`MICB at cpan.org\*(C'\fR \fI(1996\-1998, retired)\fR,
Vishal Bhatia <vishal at deja.com> I(1999),
Gurusamy Sarathy <gsar at cpan.org> I(1998\-2001),
Reini Urban \f(CW\*(C`perl\-compiler at googlegroups.com\*(C'\fR I(2008\-now),
Heinz Knutzen \f(CW\*(C`heinz.knutzen at gmx.de\*(C'\fR I(2010)
Will Braswell \f(CW\*(C`wbraswell at hush.com\*(C'\fR I(2012)
