.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLTYPES 1"
.TH PERLTYPES 1 "2018-01-01" "perl v5.22.5" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perltypes \- Perl type support
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Dynamic types"
.IX Subsection "Dynamic types"
Perl is a dynamic language with dynamic data types. The actual type is
typically determined at run-time, context-dependent and usually the operator
leads to automatic type conversions, cached in the data.
.SS "Static types"
.IX Subsection "Static types"
Perl always allowed optional declaration of static types, i.e. an
existing package name, for lexical variables and with cperl also for
function signatures. Lexicals are stored in pads, the package name,
i.e. the \f(CW\*(C`type\*(C'\fR, is stored in the stash part of the \f(CW\*(C`comppad_name\*(C'\fR
slot for each pad. Perl itself does not use these types for checks and
optimizations, only external modules or cperl do.
.PP
Remember: A type is implemented as package. A valid type must be an
existing and loaded package. Type expressions, like parametric types
or unions cannot be stored in pad stashes yet.
.PP
Global variables can not store types, ony lexicals. Constants are
implicitly typed.
.PP
\&\fBcperl\fR adds support for builtin coretypes, has type declarations for
most internal ops, and can optimize based in type inference or
declared types.
.SS "Why types? Types are unperlish"
.IX Subsection "Why types? Types are unperlish"
No, they are not. Types for lexical variables are permitted since 2001
and used in a few \s-1CPAN\s0 modules, i.e. Net::DNS.  Perl6 uses types all
over.  Every perl5 value is typed. Just all the normal ops are generic
and are allowed to change the type of its arguments and its result at
will.
.PP
Types allow dramatic performance and size optimizations, lead to
better documented code and lead to earlier compile-time errors, which
less need to test all possible run-time types with extensive test
suites, which rarely cover all type cases.
.PP
Natively types arrays are 4x smaller and faster, typed loops can lead
to static loop optimizations, array elements do not need to be checked
for out-of-bounds at run-time. There's no need to check for tied
methods or other magic for typed variables. Most of the run-time
\&\fImagic\fR, i.e. checking for extraordinary conditions can be bypassed
with typed variants. And with unboxed native types all the arithmetic
ops are at least 2\-4x faster.
.PP
Without types no multi-dispatch, no proper object system. There's no
need to overload internal methods anymore. The compiler and run-time
can dispatch on the types of its arguments.
.PP
Without types no builtin \s-1FFI,\s0 foreign function interface. You still need
to call an external \s-1FFI\s0 module or write a \s-1XS\s0 function, but loose all the
benefits of builtin types.
.PP
But even without explicit type declarations the compiler internally
can handle the arguments and result types much better as e.g. the
javascript v8 engine does, but observing the run-time types and
optimize dynamically. You don't need dart to run fast javascript but
it helps.
.SS "coretypes"
.IX Subsection "coretypes"
The builtin \f(CW\*(C`coretypes\*(C'\fR module implements efficient implementations
and \fBstrict types\fR of \f(CW\*(C`Int\*(C'\fR, \f(CW\*(C`UInt\*(C'\fR, \f(CW\*(C`Num\*(C'\fR and \f(CW\*(C`Str\*(C'\fR, which can
be applied to scalars, arrays, hashes and functions, in lexical
variable declarations and in signature declarations before the
variable name, or afterwards as attribute.
.PP
Any type change for those strictly typed variables will be detected at
compile-time and if this fails at run-time.  The type \f(CW\*(C`Int\*(C'\fR is
interpreted as \s-1IV,\s0 \f(CW\*(C`Num\*(C'\fR as \s-1NV\s0 and \f(CW\*(C`Str\*(C'\fR as \s-1PV\s0 only. There is
no stringification for \s-1IV\s0 and \s-1NV,\s0 no magic such as \*(L"tie\*(R" in perlfunc,
no setting to \f(CW\*(C`undef\*(C'\fR allowed.
.PP
.Vb 3
\&    my Int @a = (0..9);
\&    tie @a, \*(AqTie::Array\*(Aq;
\&    => compile\-time error: Invalid tie for typed array
.Ve
.PP
We provide fast ops variants for these types to omit type checks and
magic calls at run-time.
.PP
Operations on typed \f(CW\*(C`Int\*(C'\fR will not promote to double on overflow,
such as under \f(CW\*(C`use integer\*(C'\fR, but arithmetic on untyped IVs will
promote to doubles.
.PP
The \f(CW@ISA\fR of the coretypes are guaranteed to be empty. Thus there
will no parent of all, such as a generic type \f(CW\*(C`Object\*(C'\fR, \f(CW\*(C`Scalar\*(C'\fR or
\&\f(CW\*(C`Dynamic\*(C'\fR to override coretypes, but there will be \fIsubtyped\fR
children of coretypes to allow stringification and undef.  So it is
safe to optimize coretypes to its native operations at compile-time.
.PP
See also \*(L"coretypes\*(R" in perldata for examples.
.SS "native types"
.IX Subsection "native types"
Types for perl objects should have classnames names starting as
uppercase, with several reserved names for core types, see above.
.PP
The lower case variants \fBint\fR, \fBuint\fR, \fBnum\fR and \fBstr\fR are used to
handle raw unboxed values directly, not refcounted, and are permitted
for rare cases: in special sequences of ops which do understand
them. They are also useful for the \fBffi\fR (\*(L"foreign function
interface\*(R") in core, which is in development.
.PP
The compiler handles boxing and unboxing automatically for the parts
where unboxed values are not permitted on the stack. Thus you are
allowed to use native types instead of coretypes overall, and the
compiler uses the boxed variants instead as it sees fit.
.PP
Note that you are safe to declare native types to all your lexicals,
even you want to declare them only as Int, Num or Str, i.e. boxed.  A
type \f(CW\*(C`int\*(C'\fR is a hint to declare the \s-1SV\s0 a possible native \f(CW\*(C`int\*(C'\fR type,
but initially every \f(CW\*(C`int\*(C'\fR is treated as \f(CW\*(C`Int\*(C'\fR type, a normal \s-1IV.\s0
.PP
This reduces memory four to ten times per scalar, and speeds up
combinations of pure arithmetic code and natively typed arrays.
.PP
Operations on native type int will not promote to double on overflow,
arithmetic on untyped \s-1IV\s0 will promote to doubles.
.PP
\&\fBInternally\fR
.PP
The native op variants start with \f(CW\*(C`int_\*(C'\fR, \f(CW\*(C`uint_\*(C'\fR, \f(CW\*(C`num_\*(C'\fR,
\&\f(CW\*(C`str_\*(C'\fR. Any sequence of natively typed ops might need to start with
an \f(CW\*(C`unbox_\*(C'\fR op to convert the vaues on the stack from boxed to
unboxed, and end with either a \f(CW\*(C`box_\*(C'\fR op or the \f(CW\*(C`OPpBOXRET\*(C'\fR private
flag in the op.  This unboxing and boxing adds some runtime costs, so
the compiler is free to omit such type promotions at it sees
fit. However with the new \s-1FFI\s0 the native type declaration is
guaranteed to be observed by the compiler, and the unbox and box ops
are added automatically.
.PP
Unboxed native values can appear on the stack, on pads and in const
ops.
.SS "type checker"
.IX Subsection "type checker"
Compile-time type checks need to be enabled with \f(CW\*(C`use types\*(C'\fR.
.SS "type inference"
.IX Subsection "type inference"
The inferencer runs automatically on some very limited syntax and can
currently only infer \f(CW\*(C`Int\*(C'\fR on array indices, ranges and \f(CW\*(C`Str\*(C'\fR on
hash keys, but has to give up on magic, dualvars, and \f(CW\*(C`no strict
\&\*(Aqrefs\*(Aq\*(C'\fR. But the current type inference is fast.  With the help of
added declarations and type checks, as e.g. in \f(CW\*(C`smartmatch\*(C'\fR or
\&\f(CW\*(C`given\*(C'\fR/\f(CW\*(C`when\*(C'\fR with type support it can infer much more.
.PP
.Vb 1
\&    if (type $a == "int") {  => $a is an int in this scope }
.Ve
.PP
Typed lexicals and signatures lead to a typical performance win to ~2x
faster, you get compile-time type warnings, a business friendly coding
environment and the possibility to display and put infered types
automatically in your code, with a cooperating editor. e.g.
.PP
.Vb 5
\&    my $n = 1000;
\&    for (my $i=0; $i<$n; $i++) { }
\&=>
\&    my int $n :const = 1000;
\&    for (my int $i=0; $i<$n; $i++) { }
.Ve
.PP
\&\fBNote\fR: When in doubt leave out types. If the inferer cannot find it,
it might not be worth the trouble. But for hot code always use types,
as compile-time types prevent from costly run-time checks for types
and magic hooks.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "typedef (\s-1NY\s0)"
.IX Subsection "typedef (NY)"
.Vb 1
\&    typedef newtype type\-expr;
.Ve
.PP
\&\fBtypedef\fR stores a type expressions, such as a union of types (\f(CW\*(C` int | uint\*(C'\fR) or type
restrictions as in perl6 (\f(CW\*(C`int where int>0\*(C'\fR) as a new type name.
.PP
This is similar to the \f(CW\*(C`subset\*(C'\fR operator in perl6, but perl6 already
stores types as objects, while cperl still has to store types as
classnames.
.SS "typeof (\s-1NY\s0)"
.IX Subsection "typeof (NY)"
.Vb 1
\&    typeof expr
.Ve
.PP
\&\fBtypeof\fR returns the compile-time declared or inferred type of the expression.
This may be different from the run-time class name, obtained with \*(L"ref\*(R" in perlfunc or
\&\*(L"reftype\*(R" in Scalar::Util.
.SH "More type terminology"
.IX Header "More type terminology"
.SS "nominal type system"
.IX Subsection "nominal type system"
cperl implements a simple nominal type as in perl6 and most
dynamic languages, in contrast to a structural type system such as in
static languages as C or \*(C+. The name of the class or type and its
subtypes specify correctness, not the list of object fields and
methods.
.PP
\&\s-1TODO:\s0 \fBco-variant\fR vs \fBcontra-variant\fR
.SS "Compile-time type optimizations"
.IX Subsection "Compile-time type optimizations"
Since Perl 5 core does not deal with types stored in \f(CW\*(C`comppad_name\*(C'\fR
per se, type checks and optimizations were usually deferred to the
modules which implement respective types checks and optimizations, and
all those modules were broken with 5.10.
.PP
The only type optimization currently in effect in Perl 5 is constant
folding and use integer.
.PP
\&\fBcperl\fR has type declarations for most internal ops, and can optimize
these ops depending on the argument types. \fIopnames.h\fR stores
\&\f(CW\*(C`PL_op_type_variants\*(C'\fR, all possible type promotions and demotions for
each op.  \fIopcode.h\fR stores \f(CW\*(C`PL_op_type\*(C'\fR with the type declarations
of all ops.
.PP
cperl is able the change of compile-time static method calls,
determined either by name or by type and const-ness of all searched
packages to static function calls.  Thus the dynamic method search, in
which object this method is implemented is avoided. This is about ~10%
faster.
.PP

.IX Xref "http: www.perl.com pub 2000 06 p5pdigest THISWEEK-20000625.html#Method_Lookup_Speedup_ http: blogs.perl.org users rurban 2011 06 how-perl-calls-subs-and-methods.html"
.PP
\fIConstant folding\fR
.IX Subsection "Constant folding"
.PP
Right-hand-side expressions or \f(CW\*(C`:const\*(C'\fR function bodies or function
bodies with an empty prototype \f(CW\*(C`()\*(C'\fR which resolve at compile-time to
constant literals may be optimized to a \s-1CONST\s0 value, and
left-hand-side numeric ops may be optimized to use their optimized
\&\f(CW\*(C`i_\*(C'\fR or even \f(CW\*(C`int_\*(C'\fR counterparts.  Note that \f(CW\*(C`i_\*(C'\fR ops do not
overflow, the integer values just wrap around. So the type and data
range must be determined in advance and if not possible i_opt
promotion it is forbidden.
.PP
.Vb 2
\&    my $c = $a + (1 << 8);
\&    => my $c = $a + 256;  # add $a CONST(IV 256)
\&
\&    use coretypes;
\&    my int $a;
\&    my $c = $a + (1 << 8);
\&    => my $c = $a + 256;  # i_add $a CONST(IV 256)
\&
\&    { use integer;
\&      my $a = 1;
\&      my $c = $a + (1 << 8);
\&    }
\&    => my $c = $a + 256;   # padsv($a) CONST(IV 1); i_add $a CONST(IV 256)
\&
\&    { use integer;
\&      my $c = 1 + (1 << 8);
\&    }
\&    => my $c = 257;       # CONST(IV 257)
\&
\&    my $a :const = 1;
\&    my $c = $a + (1 << 8);
\&    => my $c = 257;       # CONST(IV 257)
.Ve
.PP
Unlike perl5, cperl does constant folding of function bodies even
without an empty prototype.
.PP
.Vb 1
\&    sub PI { 3.1415 }
.Ve
.PP
which is the same as the old syntax \f(CW\*(C`sub PI () { 3.1415 }\*(C'\fR
.PP
\fI:const packages\fR
.IX Subsection ":const packages"
.PP
.Vb 7
\&    package MyBase 0.01 :const {
\&      our @ISA = ();
\&      sub new { bless { @_ }, shift }
\&    }
\&    package MyChild 0.01 :const {
\&      our @ISA :const = (\*(AqMyBase\*(Aq);
\&    }
\&
\&    my $obj = MyChild\->new;
\&    => MyClass::new()
.Ve
.PP
When the method search goes only through const packages and their
const \f(CW@ISA\fR, it is not possible to inject another package at
run-time into the method search, thus the method call can be
short-cut.  This classes can be \fBfinialized\fR, and all those method
calls can be resolved at compile-time to static function calls, and
can be inlined, and therefore even more optimized.
.PP
Note that the \f(CW\*(C`package MyBase\*(C'\fR must be constant here. Otherwise
\&\f(CW&MyBase::new\fR can be deleted and \f(CW@MyBase::ISA\fR be changed to lead
a parent object at run-time.
.PP
\fITypes and const inheritance\fR
.IX Subsection "Types and const inheritance"
.PP
.Vb 7
\&    package MyBase 0.01 {
\&      our @ISA = ();
\&      sub new { bless { @_ }, shift }
\&    }
\&    package MyChild 0.01 {
\&      our @ISA = (\*(AqMyBase\*(Aq);
\&    }
\&
\&    # closed call.
\&    my MyChild $obj = MyChild\->new;
\&    => MyBase::new()
.Ve
.PP
When the left-hand side of a method call is typed, the result of the
method call must be of this type or any dependent type. \f(CW$obj\fR is
already declared of type \f(CW\*(C`MyChild\*(C'\fR, thus it cannot be of any other
run-time injected package.
.PP
.Vb 7
\&    package MyBase 0.01 {
\&      our @ISA = ();
\&      sub new { bless { @_ }, shift }
\&    }
\&    package MyChild 0.01 :const {
\&      our @ISA :const = (\*(AqMyBase\*(Aq);
\&    }
\&
\&    # open call. MyChild is of type MyBase
\&    my MyBase $obj = MyChild\->new;
\&    => MyBase::new()
.Ve
.PP
When the left-hand side of a method call is typed, the result of the
method call must be of this type or any dependent type (i.e., \f(CW\*(C`MyBase\*(C'\fR
or \f(CW\*(C`MyChild\*(C'\fR).  Since \f(CW\*(C`MyChild\*(C'\fR is constant, i.e. no \f(CW&MyChild::new\fR
method can be added at run-time, and \f(CW@MyChild::ISA\fR is also
constant, it can only be \f(CW&MyBase::new\fR, even if \f(CW\*(C`MyBase\*(C'\fR itself is
not constant.
.PP
\fILexical subs \fI\s-1NYI\s0 \- move to perlsub.pod\fI\fR
.IX Subsection "Lexical subs NYI - move to perlsub.pod"
.PP
Lexically defined subs in classes or package blocks are private methods,
invisible and unchangable.
.PP
.Vb 7
\&    package MyClass 0.01 {
\&      our @ISA = ();
\&      my sub _new { bless { @_ }, shift }
\&      sub new (...) { $_[0]\->_new(...) }
\&      my $private; # pad in maincv
\&      our $open;   # in stash
\&    }
\&
\&    ...
\&    package main;
\&    my $obj = new MyClass; # i.e MyClass\->new is valid and optimized.
\&                           # Indirect method call syntax helps.
\&
\&    my $obj = MyClass::_new(); # invalid
\&    => Undefined subroutine &MyClass::_new called
.Ve
.PP
Since \f(CW&MyClass::_new\fR is lexically defined in the package scope, the compiler
may statically optimize all method calls to \f(CW&MyClass::_new\fR to an improved entersub
(the \s-1CV\s0 being on a pad) without namespace lookup and dynamic method resolution,
without having to const \f(CW%MyClass::\fR and const \f(CW@MyClass::ISA\fR.
.PP
Lexical definition guarantees compile-time definition, which is not overridable
dynamically at run-time.
.PP
\fIExternal type modules\fR
.IX Subsection "External type modules"
.PP
External modules, such as types, typesafety or Moose,
implement their type checks or optimizations for the types they
declare or allow declaration for during execution of \*(L"\s-1CHECK\*(R"\s0 in perlmod
blocks.
.SS "\s-1XXX\s0 _\|_PACKAGE_\|_ types \fIquestionable\fP"
.IX Subsection "XXX __PACKAGE__ types questionable"
As convenience for module authors it was asked to allow declarations, like
.PP
.Vb 2
\&    package MyClass;
\&    my _\|_PACKAGE_\|_ $obj = _\|_PACKAGE_\|_\->new;
.Ve
.PP
Currently only the right-hand side is valid Perl.
.PP
This looks awful though. Refactoring of the package name should really
refactor the internal types also, besides the type of all library users.
But it would be consistent.
See <http://www.perl.com/pub/2000/06/p5pdigest/THISWEEK\-20000625.html#my_\|_\|_PACKAGE_\|_\|_obj_>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See \*(L"Constant and typed lexical variables\*(R" in perldata for the syntax
of Perl's built-in type declarations for variables, and
<https://github.com/stevan/p5\-mop/wiki/Signatures\-and\-Parameters> for
the syntax of Perl's future argument and return type declarations.
.PP
<http://perl.plover.com/classes/typing/> \fIStrong Typing Doesn't Have to Suck\fR
.PP
Most dynamic languages are currently in the process to get type
support:
.IP "<http://www.typescriptlang.org/Content/TypeScript%20Language%20Specification.pdf>  (microsoft's javascript with types)" 4
.IX Item "<http://www.typescriptlang.org/Content/TypeScript%20Language%20Specification.pdf> (microsoft's javascript with types)"
.PD 0
.IP "<https://code.facebook.com/posts/1505962329687926/flow\-a\-new\-static\-type\-checker\-for\-javascript/> (facebook's javascript with types)" 4
.IX Item "<https://code.facebook.com/posts/1505962329687926/flow-a-new-static-type-checker-for-javascript/> (facebook's javascript with types)"
.IP "<https://github.com/rwaldron/tc39\-notes/blob/master/es6/2015\-01/JSExperimentalDirections.pdf> Soundscript, google's javascript with types" 4
.IX Item "<https://github.com/rwaldron/tc39-notes/blob/master/es6/2015-01/JSExperimentalDirections.pdf> Soundscript, google's javascript with types"
.IP "<https://www.python.org/dev/peps/pep\-0484/>  (planned python with types)" 4
.IX Item "<https://www.python.org/dev/peps/pep-0484/> (planned python with types)"
.IP "<http://www.mypy\-lang.org/> (existing python with types)" 4
.IX Item "<http://www.mypy-lang.org/> (existing python with types)"
.IP "<https://news.ycombinator.com/item?id=8620129> (ruby 3.0 planned with types)" 4
.IX Item "<https://news.ycombinator.com/item?id=8620129> (ruby 3.0 planned with types)"
.IP "<http://crystal\-lang.org/> (a good existing ruby with types)" 4
.IX Item "<http://crystal-lang.org/> (a good existing ruby with types)"
.IP "<http://hacklang.org/> (facebook's php with types)" 4
.IX Item "<http://hacklang.org/> (facebook's php with types)"
.IP "<http://blog.pascal\-martin.fr/post/in\-favor\-of\-rfc\-scalar\-type\-hints.html> (php 7 types overview)" 4
.IX Item "<http://blog.pascal-martin.fr/post/in-favor-of-rfc-scalar-type-hints.html> (php 7 types overview)"
.IP "<https://wiki.php.net/rfc/scalar_type_hints> (php 7)" 4
.IX Item "<https://wiki.php.net/rfc/scalar_type_hints> (php 7)"
.IP "<https://wiki.php.net/rfc/return_types> (php 7)" 4
.IX Item "<https://wiki.php.net/rfc/return_types> (php 7)"
