.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLCPERL 1"
.TH PERLCPERL 1 "2018-01-01" "perl v5.22.5" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlcperl \- a perl5 with classes, types, compilable, company friendly
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Description of changes and enhancements of the cperl variant of perl5.
.SH "DEVELOPMENT SETUP"
.IX Header "DEVELOPMENT SETUP"
init from a perl5 git dir:
.PP
.Vb 3
\&    git remote add cp ssh://git@github.com/perl11/cperl.git
\&    git fetch cp
\&    git checkout \-t cp master
.Ve
.PP
for rerere:
.PP
.Vb 4
\&    git config \-\-add rerere enable
\&    git config \-\-add rerere.autoupdate true
\&    git submodule update \-\-init
\&    ln \-s ../.git\-rr\-cache .git/rr\-cache
\&
\&    git branch \-r | grep cp/
.Ve
.PP
We need a shared rerere cache to be able to continously merge and rebase with perl5
upstream and our branch progress.
See <https://medium.com/@porteneuve/fix\-conflicts\-only\-once\-with\-git\-rerere\-7d116b2cec67>
The commits with \fIgit-rr-cache\fR and \fIcp-rb\fR in the Subject can be safely ignored
upstream.
.PP
All branches are frequently rebased. Use the provided helpers
\&\fIcp-rb\fR, \fIcp-rbi\fR, \fIcp-lb\fR and \fIcp-rh\fR.
.PP
The tip of the best performance branch is currently
\&\f(CW\*(C`feature/CM\-712\-cperl\-types\-proto\*(C'\fR, and the memory saving branch is
\&\f(CW\*(C`feature/CM\-370\-cperl\-warnings\-xs\*(C'\fR.
.PP
\&\fB\s-1INSTALL:\s0\fR
.PP
Simple:
.PP
.Vb 4
\&    ./Configure \-sder \-Dusedevel \-Dusecperl
\&    make \-s \-j4
\&    make \-s \-j4 test
\&    sudo make install
.Ve
.PP
Experts:
.PP
.Vb 7
\&    ./Configure \-sder \-Dusedevel \-Dusecperl \e
\&      \-Accflags=\*(Aq\-msse4.2 \-DPERL_FAKE_SIGNATURE\*(Aq \-\-optimize=\*(Aq\-O3 \-g\*(Aq \e
\&      \-Dinstallman1dir=none \-Dinstallman3dir=none \-Dinstallsiteman1dir=none \e
\&      \-Dinstallsiteman3dir=none
\&    make \-s \-j4 ECHO=true
\&    make \-s \-j4 ECHO=true test
\&    sudo make install
.Ve
.PP
Debugging with private archlibs and exename:
.PP
.Vb 12
\&    git=\`git rev\-parse @|cut \-c\-7\`
\&    archname="\`uname \-s\`\-debug@$git"
\&    exesuff=d\-nt
\&    ./Configure \-sder \-Dusedevel \-Dusecperl \-DDEBUGGING \e
\&      \-Accflags=\*(Aq\-msse4.2 \-DDEBUG_LEAKING_SCALARS \-DPERL_FAKE_SIGNATURE\*(Aq \-\-optimize=\*(Aq\-g3\*(Aq \e
\&      \-Dinstallman1dir=none \-Dinstallman3dir=none \-Dinstallsiteman1dir=none \-Dinstallsiteman3dir=none \e
\&      \-Darchname="$archname" \-Darchlib="/usr/local/lib/cperl/5.22.1/$archname" \e
\&      \-Dsitearch="/usr/local/lib/cperl/site_cperl/5.22.1/$archname" \e
\&      \-Dperlpath="/usr/local/bin/cperl5.22.1$exesuff" \-Dstartperl="#!/usr/local/bin/cperl5.22.1$exesuff" \e
\&    make \-s \-j4 ECHO=true
\&    make \-s \-j4 ECHO=true test
\&    sudo make install
.Ve
.SH "Incompatible changes"
.IX Header "Incompatible changes"
cperl tries to follow the old perl5 spirit and principles, unlike
recent perl5 changes, which wildly deviate from it.
.PP
cperl can parse and run 99.9% all of perl5 code. But there are a few
incompatibilities, which arise from late perl5 signatures design
changes and 2002 constant folding changes which we do not
follow. perl5 signatures are marked as experimental after all.
.PP
\&\s-1CPAN\s0 works. 2 modules currently need patches in our distroprefs repo.
.IP "\fBIllegal prototypes die, are not stored\fR" 4
.IX Item "Illegal prototypes die, are not stored"
In perl illegal prototypes warn with \f(CW\*(Aqillegalproto\*(Aq\fR and are stored as such.
.Sp
In cperl illegal prototypes in signatures used without \f(CW\*(C`:prototype()\*(C'\fR
immediately die, they cannot be suppressed with \f(CW\*(C`no warnings
\&\*(Aqillegalproto\*(Aq;\*(C'\fR and they are not stored.
.Sp
\&\fBRationale:\fR Illegal prototypes are parsed as signatures. Illegal
signatures throw a parser error.  The \f(CW\*(Aqillegalproto\*(Aq\fR warning is
only thrown within explicit extra \f(CW\*(C`:prototype()\*(C'\fR declarations.
.Sp
Technically this is not a incompatible change, as signatures are
marked as experimental.
.IP "\fB\f(CB@_\fB is empty in functions with signatures\fR" 4
.IX Item "@_ is empty in functions with signatures"
We only copy or reference arguments to signature variables, but not to
\&\f(CW@_\fR also.  \f(CW@_\fR is empty when signatures are declared.
.Sp
\&\fBRationale:\fR With signatures copying all values to \f(CW@_\fR also leads to
double copying which is 2x slower. \f(CW@_\fR is not needed anymore. Either
use no signatures to use \f(CW@_\fR variables or use signatures.
.Sp
Technically this is not a incompatible change, as signatures are
marked as experimental.
.ie n .IP "\fBEmpty signature variables \f(CB""$""\fB die\fR" 4
.el .IP "\fBEmpty signature variables \f(CB$\fB die\fR" 4
.IX Item "Empty signature variables $ die"
Using a bare \f(CW\*(C`$\*(C'\fR sigil signature variable is illegal in cperl, but
legal in perl.
.Sp
\&\fBRationale:\fR This clashes with prototypes. A bare \f(CW\*(C`$\*(C'\fR is a prototype
declaration, not a signature. Use a name in the signature and don't
use this name in the body to get back to the same behaviour.
.Sp
Technically this is not a incompatible change, as signatures are
marked as experimental.
.IP "\fBnegative integer modulo\fR" 4
.IX Item "negative integer modulo"
With typed integer variables or integer constants the modulo operator
in cperl works like with use integer, it uses the libc functionality
for \f(CW"%"\fR; using the \f(CW\*(C`i_modulo\*(C'\fR operator which is different than the
generic perl5 \f(CW\*(C`modulo\*(C'\fR operator.
.Sp
Perl5 without use integer uses a different modulo definition:
\&\fI\*(L"If \f(CI$n\fI is negative, then \f(CI$m\fI % \f(CI$n\fI is \f(CI$m\fI minus the smallest multiple of
\&\f(CI$n\fI that is not less than \f(CI$m\fI (that is, the result will be less than
or equal to zero)\*(R"\fR from \*(L"Multiplicative Operators\*(R" in perlop.
.Sp
cperl with typed or constant integers behaves like perl5 with use
integer or before 2002, when this was changed (\f(CW\*(C`e7311069\*(C'\fR). The
compiler simply promotes \f(CW\*(C`modulo\*(C'\fR to \f(CW\*(C`i_modulo\*(C'\fR if both arguments
are integers at compile-time.  To fall back to the old behavior use
untyped variables and no integer.
.Sp
.Vb 8
\&    perl5:
\&    \-13 % 4 => 3
\&    13 % \-4 => \-3
\&    {
\&      use integer;
\&      \-13 % 4 => \-1
\&      13 % \-4 => 1
\&    }
\&
\&    cperl:
\&    \-13 % 4 => \-1
\&    13 % \-4 => 1
\&
\&    # old perl5 behavior:
\&    {
\&      no integer;
\&      ($a,$b) = (\-13,4);
\&      $a % $b => 3
\&    }
.Ve
.Sp
\&\fBBackground:\fR In
<http://www.nntp.perl.org/group/perl.perl5.porters/2001/10/msg45590.html>
p5p was arguing that it is using the mathematical \*(L"correct\*(R" semantics, vs
this definition from the C standards committee:
<http://www.open\-std.org/JTC1/SC22/wg14/www/docs/n1124.pdf>
.Sp
\&\fI"When integers are divided, the result of the / operator is the
algebraic quotient with any fractional part discarded. If the
quotient \f(CI\*(C`<a/b\*(C'\fI\fR is representable, the expression \f(CW\*(C`<(a/b)*b + a%b\*(C'\fR> shall equal a.">
.Sp
Perl does not obey this, only with use integer.
.Sp
.Vb 1
\&    use integer; my ($a,$b)=(13,\-4); print int(($a/$b)*$b) + $a % $b => 13
\&
\&    my ($a,$b)=(13,\-4); print int(($a/$b)*$b) + $a % $b => 10
.Ve
.Sp
We found only once place in a module using constant negative integers
with \f(CW\*(C`%\*(C'\fR. It is a core module, and is therefore fixed. Testing many other
\&\s-1CPAN\s0 modules found no further problems, but watch out our distroprefs repo
for future patches.
.Sp
\&\fBRationale:\fR This is a bad perl5 design change and a side-effect from using
type-promotion before constant folding.  cperl uses proper type
dispatch and with both integer arguments it promotes the \f(CW\*(C`modulo\*(C'\fR op
to \f(CW\*(C`i_modulo\*(C'\fR, which behaves differently (or \*(L"normally\*(R"). The perl5
constant folder should do the same, but does not currently.  Using
extra logic to prevent from using the libc implementation also makes perl5
\&\f(CW"%"\fR operator slower.
.IP "\fBcompile-time constant folding overflows with integer literals\fR" 4
.IX Item "compile-time constant folding overflows with integer literals"
Operations with only literal integers will not overflow to numbers,
similar to perl5 with use integer.
.Sp
Only \f(CW"+"\fR and \f(CW"*"\fR will try to use \s-1UV\s0 (an unsigned value) as result, but not
\&\s-1NV\s0 (an inexact number). All other ops besides divide and shift return
\&\s-1IV\s0 (signed integers). Note that even comparison operators are integerized.
.Sp
.Vb 4
\&    my $iv_min = \-(~0 >> 1) \- 1;   # ok
\&    my $iv_min_1 = \-(~0 >> 1) \- 2; # BUT this overflows
\&    =>
\&    my $iv_min_1 = \-(~0 >> 1) \- 2.0; # avoid overflow
\&
\&    my int $z = 4 / 5; # => number 0.8, violating the type checker
\&    # but!
\&    $z == 0; # => TRUE, because lexical int == const int uses i_eq,
\&             # the integer variant, which integerizes $z to 0
.Ve
.Sp
All coretests pass, no tests had to be changed. In practice only compile-time
constants in the negative \s-1IV_MIN\s0 to \s-1UV_MIN\s0 range will need to be fixed.
.Sp
\&\fBRationale:\fR This was the original issue 2002 which disabled automatic
integerization of all arithmetic ops with constants. \f(CW"+"\fR and \f(CW"*"\fR
are a good exceptions to allow unsigned results (with the new \f(CW\*(C`u_add\*(C'\fR
and \f(CW\*(C`u_multiply\*(C'\fR ops) to create large constants, but all other
integer operations need to be preciser when inexact numbers are
demanded, and return signed integers.
.Sp
\&\fBExceptions\fR, keeping the old behaviour:
Division for two integer constants is an internal exception and
is not promoted to use integer division. \f(CW\*(C`2/5 => 0.4\*(C'\fR
Compile-time shift operations return unsigned integers.
.SH "Fix breakage and bad design"
.IX Header "Fix breakage and bad design"
.SS "signatures"
.IX Subsection "signatures"
The p5p signature implementions is still lacking many important
features and is twice as slow as doing without, and twice as slow as
the cperl implementation which uses the stack variables directly
without copying them to \f(CW@_\fR. There is no point in using it.  It is
the biggest cause for backwards incompatible changes, but it is marked
as experimental, so the perl5 implementation can eventually be
improved, and our changes are technically not incompatible.
.IP "\fBAdd optional types in signatures\fR" 4
.IX Item "Add optional types in signatures"
.Vb 2
\&    sub (int $i)   # as in Perl6, or
\&    sub ($i: int)  # as in the other gradual typed languages
.Ve
.Sp
We use the samed syntax as provided for lexical variable
declarations. In both variants, in leading position as with \f(CW\*(C`my int
$a;\*(C'\fR and as attribute, as with \f(CW\*(C`($i :int :const)\*(C'\fR
.Sp
We need to seperate coretypes (int, uint, str, num) and user-defined types
(existing class names), and the 2 core attributes \f(CW\*(C`:const\*(C'\fR and
\&\f(CW\*(C`:unsigned\*(C'\fR. For more perl6 like traits see below.
.Sp
Follow the same rules as in lexical declarations. The type must exist
already as package, otherwise a syntax error is thrown.
.Sp
.Vb 2
\&    $ cperl \-e\*(Aqsub x(x $x){}\*(Aq
\&    No such class x at \-e line 1, near "sub x(x"
\&
\&    $ cperl \-e\*(Aqsub x(str $s){}\*(Aq          # coretypes implicitly loaded
\&
\&    $ cperl \-e\*(Aq%MyStr::; sub x(MyStr $s){}\*(Aq  # user\-defined type MyStr
.Ve
.IP "\fBAdd subroutine return types\fR" 4
.IX Item "Add subroutine return types"
For easier implementation we support subattributes, \f(CW\*(C`:<type>\*(C'\fR only,
not the other possible syntax variants \f(CW\*(C`=> type\*(C'\fR or \f(CW\*(C`returns type\*(C'\fR.
.Sp
There are just a few semantic conflicts.
Note that we can use the builtin attributes \f(CW\*(C`:lvalue\*(C'\fR, \f(CW\*(C`:method\*(C'\fR,
\&\f(CW\*(C`:const\*(C'\fR and \f(CW\*(C`:unsigned\*(C'\fR also here.
.Sp
\&\f(CW\*(C`:const\*(C'\fR does not mean constant result, it rather means constant
subroutine.  Having this constant means that the compiler is able to
inline it without run-time checks if it has changed.
.Sp
\&\f(CW\*(C`:unsigned\*(C'\fR as coretype or not?  As sub attribute it could mean
strictly typed to a return result of \f(CW\*(C`UV\*(C'\fR, like \f(CW\*(C`:int :unsigned\*(C'\fR,
where the \f(CW\*(C`:int\*(C'\fR is optional. \f(CW\*(C`:\-unsigned\*(C'\fR would mean \f(CW\*(C`:int\*(C'\fR then,
return a signed int.  \f(CW\*(C`:unsigned\*(C'\fR could also be no coretype, just a
hint for \f(CW\*(C`:int\*(C'\fR, and without \f(CW\*(C`:int\*(C'\fR it will just be an attribute,
not a strictly checked coretype. This decision is still open.
.IP "\fBAdd call by-ref via \e$arg\fR" 4
.IX Item "Add call by-ref via $arg"
Support scalar lvalue references \- sub (\e$var)
.Sp
With perl5 upstream all arguments are copied only, as with \f(CW\*(C`my $arg1 = shift;\*(C'\fR but
alternate syntax for fast \f(CW$_[0]\fR access is not provided. So they have to keep
the otherwise unneeded \f(CW@_\fR array around.
.Sp
cperl uses \f(CW\*(C`\e$name\*(C'\fR to denote references to scalar lvalues, which change the
calling variable.
.Sp
.Vb 4
\&    sub myfunc(int \e$i) : int { $i++; }
\&    my $i;
\&    print myfunc($i); => 1
\&    print $i;         => 1
.Ve
.Sp
For now scalar lvalue references only, \f(CW\*(C`\e@a\*(C'\fR or \f(CW\*(C`\e%h\*(C'\fR would be nice with
type checks for arrayref or hashref.  maybe \f(CW\*(C`\e[$]\*(C'\fR also.
.IP "\fBImprove \f(CB@_\fB handling\fR" 4
.IX Item "Improve @_ handling"
Remove \f(CW@_\fR when not needed. Use the mark stack as in the ops.
.Sp
With cperl \f(CW@_\fR will only hold the \f(CW&rest\fR args, the undeclared rest
if no other slurpy args are declared.  i.e. \f(CW@_\fR will be empty when
signatures are declared with a slurpy ending \f(CW\*(C`@\*(C'\fR or \f(CW\*(C`%\*(C'\fR arg, and
\&\f(CW@_\fR is not referenced in the immediate function body, visible to
the compiler, i.e. not hidden by a string eval.
.Sp
We want to use the mark stack for signature calls, same as with \s-1OPS,\s0 we don't
need to copy to \f(CW@_\fR.
.Sp
Internally the elements of \f(CW@_\fR are currently accessed via aelem, not
aelemfast.  But this is moot with the introduction of the new \s-1OP_SIGNATURE\s0
op, which is even faster.
.Sp
With the old 5.18\-5.22 implementation the perl5 arity check is overly
big and needs two checks and big strings with fixed arity subs.
.Sp
.Vb 10
\&    perl \-MO=Deparse \-e\*(Aqsub x($a){$a++}\*(Aq
\&    sub x {
\&        die sprintf("Too many arguments for subroutine at %s line %d.\en",
\&          (caller)[1, 2]) unless @_ <= 1;
\&        die sprintf("Too few arguments for subroutine at %s line %d.\en",
\&          (caller)[1, 2]) unless @_ >= 1;
\&        my $a = $_[0];
\&        ();
\&        $a++;
\&    }
.Ve
.Sp
cperl changes all arity errors to \*(L"Wrong number arguments\*(R".
.Sp
.Vb 8
\&    cperl \-MO=Deparse \-e\*(Aqsub x($a){$a++}\*(Aq
\&    sub x {
\&        die sprintf("Wrong number arguments for subroutine %s at %s line %d.\en",
\&          (caller(0))[3, 1, 2]) if @_ != 1;
\&        my $a = $_[0];
\&        ();
\&        $a++;
\&    }
\&
\&    cperl \-MO=Deparse \-e\*(Aqsub x(\e$a){$a++}\*(Aq
\&    sub x {
\&        die sprintf("Wrong number arguments for subroutine %s at %s line %d.\en",
\&          (caller(0))[3, 1, 2]) if @_ != 1;
\&        $_[0]++;
\&    }
.Ve
.IP "\fBSupport default \f(CB$self\fB invocant with methods (\s-1NY\s0)\fR" 4
.IX Item "Support default $self invocant with methods (NY)"
If a method is declared as such (via \f(CW\*(C`method\*(C'\fR or \f(CW\*(C`sub :method\*(C'\fR) the \f(CW$self\fR
argument is used as default invocant argument name, which can be overridden
via the \f(CW\*(C`($class: $args,...)\*(C'\fR colon syntax.
.Sp
.Vb 1
\&    sub adder ($a) :method { $self\->{add} + $a; }
.Ve
.IP "\fBAdd :pure attribute for subroutines\fR" 4
.IX Item "Add :pure attribute for subroutines"
You can flag a function as purely functional, without any
side-effects, to allow further compiler optimizations.  Note that pure
functions may throw, but may not access globals or do \s-1IO.\s0
.Sp
A pure function only reacts to its input arguments and will always
return the same value with the same arguments, thus can be safely
memoized or constant-folded or inlined without having to embed them
into \s-1ENTER/LEAVE\s0 blocks.
.IP "\fBParse signatures with the parser, not undocumented functions (\s-1NY\s0)\fR" 4
.IX Item "Parse signatures with the parser, not undocumented functions (NY)"
\&\fIWe'll see later on this one. Maybe keep it as horrible as it is now.\fR
.IP "\fBImproved error reporting\fR" 4
.IX Item "Improved error reporting"
In violations do not only print the position, also the declaration
which is violated.  e.g.
.Sp
.Vb 1
\&    @a=(); sub x(\e@b) {$b\->[0]++} print x(\e$a)
.Ve
.Sp
\&\f(CW\*(C`Type of arg 1 to main::x must be arrayref (not a scalar ref) at \-e
line 1, near "\e$a)"\*(C'\fR
.Sp
\&\f(CW\*(C`=>\*(C'\fR
.Sp
\&\f(CW\*(C`Type of arg 1 \e@b to x must be arrayref (not a scalar ref) at
\&\-e line 1, near "\e$a)"\*(C'\fR
.Sp
Proper signature types are not only a great help for catching errors
early or improve documentation. They are performance critical, see
coffescript, dart, microsoft typescript, google soundscript, facebook
hack, mypy, ruby 3.0 and partially even perl6.  The type inferencer
will not be able to infer many types without explicit types.  But with
typed signatures, besides the obvious solution of private methods or
closed classes we can inline most small methods, ignore run-time magic
and improve most loops and array accesses. It is also critical to
implement multi methods (compile-time optimized generics) and
implement an advanced object system.
.Sp
Note that the reported main subroutines are listed without the
\&\f(CW\*(C`main::\*(C'\fR prefix.
.ie n .IP "\fBSupport \f(CB""...""\fB for efficient varargs passing (\s-1NY\s0)\fR" 4
.el .IP "\fBSupport \f(CB...\fB for efficient varargs passing (\s-1NY\s0)\fR" 4
.IX Item "Support ... for efficient varargs passing (NY)"
\&\f(CW\*(C`...\*(C'\fR as empty function body already has a special meaning as \fByadayada\fR
operator, just croaking, but interestingly not the usual meaning of varargs.
.Sp
cperl uses \f(CW\*(C`...\*(C'\fR in the natural way to denote unnamed and uncopied
rest args, and passes the varargs through to the next call.
.Sp
\&\f(CW\*(C`...\*(C'\fR denotes a slurpy unnamed signature, and \f(CW\*(C`...\*(C'\fR in a otherwise
non-empy function body denotes passing those arguments efficiently to
the next function.  Internally \f(CW\*(C`...\*(C'\fR does not need to copy the values
into a temporay array, we just need to pass the argument stack
position down to the next calls using \f(CW\*(C`...\*(C'\fR. By using \f(CW\*(C`...\*(C'\fR instead
of \f(CW@_\fR we can avoid copying the values to \f(CW@_\fR, we only need the stack
index, not all the values.
.Sp
.Vb 1
\&    sub foometh($self, ...) { func(...) }
.Ve
.IP "\fBstrict prototype and signature syntax, no pragmas required.\fR" 4
.IX Item "strict prototype and signature syntax, no pragmas required."
Illegal prototype and signature syntax does not just warn, it dies with
an syntax error as it should be.
.Sp
.Vb 2
\&    $ cperl \-e\*(Aqno warnings "illegalproto"; sub x(x){}\*(Aq
\&    No such class x at \-e line 1, near "sub x(x"
.Ve
.Sp
\&\f(CW\*(C`no warnings "illegalproto";\*(C'\fR is a noop.
.IP "\fBno feature signatures or lexsubs or lexical_topical pragmas required\fR" 4
.IX Item "no feature signatures or lexsubs or lexical_topical pragmas required"
\&\f(CW\*(C`use feature "signatures"\*(C'\fR or \f(CW\*(C`use feature "lexsubs"\*(C'\fR is not
required and is ignored.  All prototypes and signatures are parsed either
as prototypes or signature, regardless of the scope of a \f(CW\*(C`use feature
"signatures"\*(C'\fR pragma. \f(CW\*(C`my sub\*(C'\fR is parsed without previous activation.
.Sp
\&\f(CW\*(C`my $_\*(C'\fR does not require \f(CW\*(C`use experimental::lexical_topic\*(C'\fR.
\&\f(CW\*(C`use cperl\*(C'\fR can be used, if incompatible features are used, but it is optional.
.ie n .SS "Fix my $_ handling"
.el .SS "Fix my \f(CW$_\fP handling"
.IX Subsection "Fix my $_ handling"
Perl5 had long-standing problems with lexical \f(CW$_\fR since the introduction
of the \s-1SASSIGN\s0 optimization via \s-1OA_TARGLEX\s0 and OPpTARGET_MY in 2002.
.PP
cperl fixed this (it was using a wrong bit-testing, using \s-1AND\s0 as \s-1OR\s0)
and work is ongoing to harmonize further internal code exceptions and
code-smell, e.g. \s-1SASSIGN,\s0 given/when and the match functions.
.SS "Undo B bootstrap breakage"
.IX Subsection "Undo B bootstrap breakage"
B was changed to support \f(CW\*(C`use strict\*(C'\fR from the very beginning,
which broke the B::Bytecode compiler performance advantage, adding
all compiler internal constants to the emitted bytecode.  Reverting
this breakage was denied because this developer did not understand the
code.  It is too bothersome in the long run to maintain our reversion
of this breakage over years.  It easier to check for \fIusecperl\fR in
the compiler to be able to compile to bytecode properly again.
.SS "Undo constant folding i_opt de-optimization"
.IX Subsection "Undo constant folding i_opt de-optimization"
Automatic integer optimizations for constants were removed from
constant folding against community consent in the early times with
commit \f(CW\*(C`e7311069\*(C'\fR.
.PP
We re-add this optimization to treat constant integers and typed
lexicals as such (as via an implicit use integer) in constant foldable
expressions. I.e. integer overflow in constant expressions is only
checked at compile-time, not run-time.
.PP
We re-instate the two special cases for I_DIVIDE and I_MODULO, which
deviate from the untyped generic variants. div int / int returns a
float even with constants, and mod with negative integers uses the
standard C variant only if typed or within use integer. The untyped
variant uses the perl5 definition of modulo as in group theory, which
violates the definition of a remainder.
.PP
.Vb 3
\&    my int $i = \-3; $i % 2 => \-1, not 1.
\&    \-3 % 2 => \-1, not 1.
\&    1/2 => 0.5 (unchanged)
.Ve
.PP
We are also now able to do constant-folding on subroutine bodies, to
either inline the body into the caller or replace the body with a
constant in the general case. (i.e. without the \f(CW\*(C`()\*(C'\fR prototype)
.SS "Undo support for binary names (\s-1NY,\s0 maybe)"
.IX Subsection "Undo support for binary names (NY, maybe)"
By announcing unicode support for names p5p silently allowed \f(CW\*(C`\e0\*(C'\fR
inside names, which they called an advantage by supporting now binary
safe names and \*(L"harmonization\*(R".  In reality unicode names were already
supported since 5.8.4 and the whole 5.16 unicode name theatre was only
about binary names.  They didn't support binary names in all other
code parts which had to deal with names, and thus enabled a huge
attack vector to hide arbitrary user strings behind \f(CW\*(C`\e0\*(C'\fR names, which
was silently stripped before and when used in syscalls.  They moved
resonsibility to the user, as previously for input strings only, now
also for input names, e.g. for package names which search the
filesystem directly without sanitation or proper checks. Support for
those binary names is still not complete with 5.24 in core, even if
p5p pushed so strong for it against my protest.
.PP
We have to keep the new \s-1GV API\s0 \- accepting the string length \- but
even without \f(CW\*(C`strict names\*(C'\fR we strip everything behind the \f(CW\*(C`\e0\*(C'\fR as
before 5.16.
.PP
For a more efficient dynamic namespace implementation we might be
switching from chained hash tables to a single ternary trie, radix
tree or \s-1DAFSA,\s0 without support for \f(CW\*(C`\e0\*(C'\fR and maybe even without
optional support for unicode names. Only with \f(CW\*(C`use utf8\*(C'\fR we might
need to fallback to the old slow method then.
.SS "Warn on \e0shellcode attempts for names"
.IX Subsection "Warn on 0shellcode attempts for names"
Make our \f(CW\*(C`use warnings "syscalls"\*(C'\fR the default.
.PP
Any attempt to attack package names with shellcode behing \f(CW\*(C`\e0\*(C'\fR is
being warned per default, and not only optionally with \f(CW\*(C`use warnings
"syscalls"\*(C'\fR. There is no uninnocent or wrong usage of such names, only
malicious intent, and this must appear in logfiles.  This is worse than
syntax errors and syntax errors are warned by default. p5p was
vehemently against this change.
.SS "strict names (\s-1NY\s0)"
.IX Subsection "strict names (NY)"
With \f(CW\*(C`use strict "names"\*(C'\fR we do not accept unparsable symbols created
from strings.  This is a new run-time error for use strict.
.PP
There's currently no room for an explicit \f(CW\*(C`use strict \*(Aqnames\*(Aq\*(C'\fR hint
due to a bad strict implementation. But later when we freed some
\&\f(CW\*(C`PL_hint\*(C'\fR bits to hold strict defaults we can add support for that.
.SS "\s-1TR39\s0 confusable names (\s-1NY\s0)"
.IX Subsection "TR39 confusable names (NY)"
Reject confusables as described in \s-1TR39.\s0 Theoretically this can be
added with \*(L"strict names (\s-1NY\s0)\*(R" only, but since this is only dangerous since
v5.16 we can just throw a syntax error by default as in other languages
with proper unicode support, e.g. \fIJava\fR.
.PP
The compiler had to add this warning since 5.16:
.PP
\&\fIPerl handling of new unicode identifiers \- package and symbol names \-\fR
\&\fIwithout proper \s-1TR39\s0 handling is considered a security risc and is not fully supported.\fR
\&\fISee\fR <http://websec.github.io/unicode\-security\-guide/>.
.PP
\&\fICheck your code for syntax spoofs, confusables, strip \e0 from package names\fR
\&\fIand enable use warnings 'syscalls'\fR.
.SS "Undo the double readonly system"
.IX Subsection "Undo the double readonly system"
In order to support Hash unlock code, i.e. undoing readonly setting of
hash values, p5p added a second readonly bit \f(CW\*(C`SVf_PROTECT\*(C'\fR for
special values which are not allowed to be writable, even if the
better solution to check for this special values at Hash unlock would
have been trivial.  It does not need to take away the last free \s-1SV\s0
bit, which we used to implement coretype checks on pad values, and
unlock really only needs to unlock the previously locked values, not
make all values unconditionally writable, thus making previously
readonly values writable. \f(CW\*(C`SVf_PROTECT\*(C'\fR does not help with that.
.PP
\&\f(CW\*(C`SVf_PROTECT\*(C'\fR is now the same as \f(CW\*(C`SVf_READONLY\*(C'\fR, and special checks
were added for the two usecases when the readonly bit is unset.  We
need the \f(CW\*(C`SVf_PROTECT\*(C'\fR bit to mark native \s-1SV\s0's in pad's, and even
reserved it in 2012.
.SS "Fix the hashes"
.IX Subsection "Fix the hashes"
Provide proper hash table abstractions. We don't need 5 times the same
bad code copied along for all different kind of \s-1HEK\s0 (hash key) types.
.PP
Do not check the hash key for collisions with 4 different comparisons
in the hot hash loop, use one instead.
.PP
For the old hash tables use the new default strategy
\&\s-1PERL_PERTURB_KEYS_TOP\s0 to move each found bucket to the top of the
chain. This is how you usually implement a hash table with linked
lists.
.PP
Use fast hash functions, not secure slow ones. We get security by
fixing the algorithmic problem, not by obscuring the users and fellow
developers.  We properly analyzed many hash functions and hash tables,
for security and speed. The fastest, FNV1a, was the one the fellow
developer schmorp choose \fIby his guts\fR in his stableperl fork.
.PP
Provide a Configure argument to define the hash function: \-Dhash_func=FNV1A
.PP
Make the load factor definable, and change the default from 100% to
90%, which was tested as superior.
Use \f(CW\*(C`\-Accflags=\*(Aq\-DHV_FILL_RATE=100\*(Aq\*(C'\fR for the old behavior.
.PP
\&\fBFurther plans:\fR
.PP
Hash functions need to be implemented as macros, not functions, undo
that. (\fImaybe\fR)
.PP
Use cache-friendly open addressing, not simple, slow and \s-1DOS\s0'able
(i.e. insecure) linked lists. Fix the \*(L"security issues\*(R", i.e. denial
of service issues properly.
.PP
Seperate the keys from the values to fit the search into a cache line.
.PP
Provide a special \f(CW\*(C`:const\*(C'\fR hash table type to enable optimizations to
perfect hashes. With \f(CW\*(C`study %hash\*(C'\fR you can do the similar costly
optimizations on non-const hashes to allow faster key access.
.SS "Compile-time attribute hooks"
.IX Subsection "Compile-time attribute hooks"
\&\f(CW\*(C`CHECK_SCALAR_ATTRIBUTES\*(C'\fR (for \f(CW\*(C`:const\*(C'\fR, \f(CW\*(C`:int\*(C'\fR, \f(CW\*(C`:num\*(C'\fR, \f(CW\*(C`:str\*(C'\fR)
This is basically a read-only \f(CW\*(C`MODIFY_*_ATTRIBUTES\*(C'\fR hook at
compile-time with a better name to disassociate from the run-time
check of \f(CW\*(C`FETCH_*_ATTRIBUTES\*(C'\fR with \f(CW\*(C`my\*(C'\fR lexicals.  See also
\&\*(L"Rewrite critical core modules in C as builtins\*(R" below.
.SS "coretypes: Int, UInt, Num, Str"
.IX Subsection "coretypes: Int, UInt, Num, Str"
coretypes can only be built-in. Provide the 4 basic ones, and the
combinations with \f(CW\*(C`Undef\*(C'\fR, and the lowercase native types.
Type combination are done via \f(CW@ISA\fR, i.e.
.PP
.Vb 1
\&    class ?Int :const { our @ISA :const = qw(Int Undef); }
.Ve
.PP
Our coretypes classes and its members are readonly.  Provide fast ops
variants for these types to omit type checks and magic calls at
run-time.  Scalars declared as \f(CW\*(C`Int\*(C'\fR, \f(CW\*(C`Uint\*(C'\fR, \f(CW\*(C`Num\*(C'\fR, \f(CW\*(C`Str\*(C'\fR cannot
hold magic associations, such as \f(CW\*(C`tie\*(C'\fR.
.PP
We also enabled the \f(CW\*(C`:const\*(C'\fR attribute for all data: scalar, arrays,
hash, functions, packages+classes.
.PP
At compile-time most \s-1UNOP\s0's and \s-1BINOP\s0's are promoted from the generic
ops to more specific typed ops, similar to \f(CW\*(C`use integer\*(C'\fR. But use
integer does not know the types of the variables at compile-time, many
ops are only dispatched at run-time.
See e.g. \*(L"negative integer modulo\*(R".
.PP
See \*(L"coretypes\*(R" in perltypes and \*(L"Constant and typed lexical variables\*(R" in perldata.
.SS "native unboxed types: int, uint, num, str (\s-1NY\s0)"
.IX Subsection "native unboxed types: int, uint, num, str (NY)"
Internally the types for all scalar \s-1SV\s0's always start with uppercase
classnames, same as with most user-defined classes. The four
lower-case variants \f(CW\*(C`int\*(C'\fR, \f(CW\*(C`uint\*(C'\fR, \f(CW\*(C`num\*(C'\fR, \f(CW\*(C`str\*(C'\fR denote possible
optimizations to direct unboxed values on the stack, which are not
reference counted, and cannot yet be used across function calls. They
are only safe to use within certain op sequences, and those
optimizations are done automatically.
.PP
Unlike all other types native types are only hints, not promises. The
compiler promotes data and code to native types only if its sees fit.
.PP
With \s-1PERL_NATIVE_TYPES\s0 enabled, most literal constants are stored as
native types, native type declarations are a promise not a hint, and
the optimizations involves up\- and downgrading of data and ops in
possible native chains. This leads to much tighter native expressions,
with performance and memory gains. (3x less memory, ~3x faster).
.PP
For the builtin \s-1FFI\s0 we will also provide FFI-specific native types,
like int32, int64, uint32, uint64 and ptr.
.PP
See \*(L"native types\*(R" in perltypes.
.SS "types"
.IX Subsection "types"
Provide a compile-time type inferencer, type checker and type
optimizer. The inferencer runs automatically and can currently only
infer \f(CW\*(C`int\*(C'\fR on array indices, ranges and \f(CW\*(C`str\*(C'\fR on hash keys, but has
to give up on magic, dualvars, and \f(CW\*(C`no strict \*(Aqrefs\*(Aq\*(C'\fR. With the help
of declarations and type checks, as e.g. in \f(CW\*(C`smartmatch\*(C'\fR or
\&\f(CW\*(C`given\*(C'\fR/\f(CW\*(C`when\*(C'\fR with type support it can infer much more.
.PP
.Vb 2
\&    if (type $a eq "int") {  => $a is an int in this scope }
\&    $str =~ /(\ed+)/; => $1 is a typed Int
.Ve
.PP
Compile-time type checks need to be enabled with \f(CW\*(C`use types;\*(C'\fR though.
.PP
Typed signatures are backwards incompatible to perl5, as the
trivial 4 line changes are still not yet supported upstream. The
performance win is ~2\-10x faster, you get compile-time type
warnings, a business friendly coding environment and the possibility
to display and put infered types automatically in your code, with a
cooperating editor. e.g.
.PP
.Vb 5
\&    my $n=1000;
\&    for (my $i=0; $i<$n; $i++) { }
\&=>
\&    my int $n :const = 1000;
\&    for (my int $i=0; $i<$n; $i++) { }
.Ve
.PP
\&\fBNote\fR: When in doubt leave out types. If the inferer cannot find it,
it might not be worth the trouble. But for hot code and to be precise
always use types, as compile-time types prevent from costly run-time
checks for types and magic hooks.
.PP
\&\fBBuiltin types\fR are the coretypes Int, Num, Str, UInt, ?Int, ?Num, ?Str
and for builtin op-dispatch: Void int uint num str Int UInt Num Str
Bool Numeric Scalar Ref Sub Array Hash List Any, with
a \f(CW\*(C`?\*(C'\fR prefix denoting \f(CW\*(C`| Undef\*(C'\fR \fI\*(L"or undef\*(R"\fR, a \f(CW\*(C`?\*(C'\fR suffix
optional, and for aggregate types using \f(CW\*(C`()\*(C'\fR brackets, like \f(CW\*(C`:Array(:Int)\*(C'\fR.
.PP
\&\fBStatus\fR: User code in pure perl or \s-1XS\s0 is currently not typed-checked
nor inferred, only internal ops. Wrong type declarations still lead to
type violation errors.
.SS ":const for all"
.IX Subsection ":const for all"
Our \f(CW\*(C`:const\*(C'\fR attribute applies to all data types: scalar, arrays, hash,
functions, packages + classes. \f(CW\*(C`:const\*(C'\fR hashes should of course be
perfect, i.e. optimized to constant-time lookup, eliminating hash
collisions.
.PP
See \*(L":const\*(R" in perltypes.
.SS "Compile-time optimizations"
.IX Subsection "Compile-time optimizations"
cperl adds many more traditional compile-time optimizations: more and
earlier constant folding, type promotions, shaped arrays, usage of
literal and typed constants, loop unrolling, omit unnecessary array
bounds checks, function inlining and conversion of static method calls
to functions.
.PP
Perl 5 only inlines constant function bodies with an explicit empty \f(CW\*(C`()\*(C'\fR
prototype.
.PP
.Vb 2
\&    sub x() {1+2} # inlined in perl5
\&    sub x   {1+2} # inlined in cperl only
.Ve
.PP
cperl inlines constant function bodies even without empty prototype
declaration, has type declarations for most internal ops, and
optimizes these ops depending on the argument types; currently for all
arithmetic unops and binops, and the data-accessing ops padsv, svop,
and sassign. \fIopnames.h\fR stores \f(CW\*(C`PL_op_type_variants\*(C'\fR, all possible
type promotions for each op.  \fIopcode.h\fR stores \f(CW\*(C`PL_op_type\*(C'\fR with
the type declarations of all ops.
.PP

.IX Xref "http: www.perl.com pub 2000 06 p5pdigest THISWEEK-20000625.html#Method_Lookup_Speedup_ http: blogs.perl.org users rurban 2011 06 how-perl-calls-subs-and-methods.html"
.PP
Small non-constant bodies may be inlined automatically, with the args
replaced in the body. constants args and literals are replaced as is,
also args as simple rvalues. lvalue args are checked for call-by-ref or
call-by-value semantics, and use the arg either directly or as copy.
.PP
With shaped arrays and it's new unchecked \f(CW\*(C`aelem_u\*(C'\fR variants, loop bodies are
optimized when the upper loop bound is declared via \f(CW$#\fR, the \fIarylen\fR.
.PP
.Vb 1
\&    for (0..$#array) {  .. $array[$_] .. }
.Ve
.PP
Here the \f(CW$array[$_]\fR call does no bounds check of the index, since
\&\f(CW$#array\fR is the last valid index, and we do not shrink the array in
the loop, even if the array is not explicitly declared as shaped array.
.PP
Work is ongoing in loop unrolling, function inlining and speculative
method inlining, which should speed up run-time performance
dramatically and enable new optimizations, which were previously
stopped on each function call border.  Planned is also polymorphic
inline caching with a usage counter, not just naive monomorphic inline
cache for method calls.
.PP
Check the new \s-1DEBUGGING\s0 option \f(CW\*(C`\-Dk\*(C'\fR which lists all optimizations
and checks at compile-time, optionally verbose together with \f(CW\*(C`\-Dkv\*(C'\fR.
.PP
\fIStatic method calls\fR
.IX Subsection "Static method calls"
.PP
.Vb 2
\&    strict\->import(...)
\&    => strict::import("strict", ...)
.Ve
.PP
When the method is defined directly in the package, it is not possible
to inject another package at run-time into the method search, thus the
method call is optimized from a dynamic method dispatch to a normal
static functions call.
.SS "Typed and shaped arrays"
.IX Subsection "Typed and shaped arrays"
Enable faster array access, uniformly typed array values, use less
memory (cache friendly), help the type system. See perltypes.
.PP
Type arrays specify the uniform type of the values. Typed arrays with
native types use much less memory and provide faster direct access.
.PP
Shaped arrays define a compile-time constant \*(L"shape\*(R", the size, which
cannot be changed.  All values are pre-initialized.
.PP
.Vb 2
\&  my int @a[20];         # or
\&  my @a[20] :int;
.Ve
.PP
With known indices the compiler can omit bounds checks on array accesses.
.PP
.Vb 2
\&    my int @a[5];
\&    for (0..$#a) { $a[$_] ... }
.Ve
.PP
Here \f(CW$a[$_]\fR uses the unchecked aelem_u operator, because the index
\&\f(CW$_\fR cannot be out of bounds.
.PP
Shaped arrays are pre-initialized according to its type and cannot
change the size. Attempts are caught at compile-time or run-time.
With constant or type-checked indices in range the access op is
optimized to omit the bounds check, via unchecked aelem variants.
Negative constant indices are converted to positive at compile-time.
.SS "Typed and shaped hashes (\s-1NY\s0)"
.IX Subsection "Typed and shaped hashes (NY)"
.Vb 7
\&  my int %h;             # or
\&  my str %a;             # hash with str values only
\&  my int %a{20};         # hash with int values only. fixed hash size,
\&                         # no grow on insertion.
\&  my str %a{20} :const   # fixed hash size, no grow on insertion,
\&                         # perfect hash (keys may not change, values do).
\&     = (...);
.Ve
.PP
No sparse arrays (i.e. hash with int keys) yet. but this would need a
different declaration syntax if to be supported natively.
.PP
e.g. \f(CW\*(C`my int %a{int};\*(C'\fR \- sparse array with int keys and int values.
or \f(CW\*(C`my %a : hash(int);\*(C'\fR
.PP
variant 2: \f(CW\*(C`my IntSparseHash %a\*(C'\fR, which can go with a user class
and methods, but this will be slow, without native ops.
.SS "Inlined functions (\s-1NY\s0)"
.IX Subsection "Inlined functions (NY)"
If a function body is inlinable, i.e. simple, with no control ops like
return, goto caller, warn, die, reset, runcv, padrange, adds no
seperate lexicals and has less than 10 ops, they are inlined.  Static
methods are converted to functions before and then possibly inlined.
This is the most important optimization, even more important then a jit.
.SS "Rewrite critical core modules in C as builtins"
.IX Subsection "Rewrite critical core modules in C as builtins"
Builtins: \f(CW\*(C`strict\*(C'\fR, \f(CW\*(C`attributes\*(C'\fR, \f(CW\*(C`DynaLoader\*(C'\fR, \f(CW\*(C`XSLoader\*(C'\fR.
\&\s-1NY:\s0 \f(CW\*(C`Carp\*(C'\fR, \f(CW\*(C`Exporter\*(C'\fR.
.PP
As shared lib: \f(CW\*(C`Config\*(C'\fR, \f(CW\*(C`warnings\*(C'\fR and \fIunicode folding tables\fR to save
memory, startup time and reduce bloat.
.PP
Big constant hashes and tables need to be in a shared memory segment,
not recompiled for every fork or thread, similar to the Encode tables
which are implemented properly. The risc to introduce even more performance
regressions by keeping some critical core modules as \fI.pm\fR is too high
and broke the compiler too often. Most developers have no idea of the
impact of innocently looking additions.
.PP
We need to reduce memory, and want to reduce the size of compiled code
by 30%, but in some cases it will be 200%.
As builtin or shared library we go to zero startup-time overhead for those
modules.
With compiled Config alone the memory savings are down to 5.6 levels.
.PP
\fIstrict 1.10c as builtin\fR
.IX Subsection "strict 1.10c as builtin"
.PP
Starting with cperl (based on Perl 5.22) strict is now a builtin module,
implemented as \s-1XS\s0 functions which are always available.
.PP
\&\fBChanges:\fR
.PP
\&\fIstrict.pm\fR is only provided for documentation, \f(CW\*(C`$INC{\*(Aqstrict.pm\*(Aq} =
\&\*(Aqxsutils.c\*(Aq\*(C'\fR With a list of wrong tags only the wrong tags are
reportyed one-by-one, and not together.  All other functionality stays
the same.
.PP
\fIattributes 0.26_01c as builtin\fR
.IX Subsection "attributes 0.26_01c as builtin"
.PP
Starting with cperl (based on Perl 5.22) attributes is now again a
builtin \s-1XS\s0 module.  There's no need to dynaload it at parse time.
.PP
\&\fIattributes.pm\fR moved back to \fIlib/attributes.pm\fR and is only provided for
documentation and import.
.PP
\&\f(CW\*(C`CHECK_\f(CItype\f(CW_ATTRIBUTES\*(C'\fR is a new compile-time hook, like a readonly
variant of \f(CW\*(C`MODIFY_\f(CItype\f(CW_ATTRIBUTES\*(C'\fR, or the compile-time variant of
\&\f(CW\*(C`FETCH_\f(CItype\f(CW_ATTRIBUTES\*(C'\fR.
.PP
There are several new builtin attributes:
.IP "\fB:const for all types\fR" 4
.IX Item ":const for all types"
.PD 0
.IP "\fB:unsigned for all integer types, sets SvIsUV_on|off\fR" 4
.IX Item ":unsigned for all integer types, sets SvIsUV_on|off"
.IP "\fBexisting classes as types are recognized\fR" 4
.IX Item "existing classes as types are recognized"
.PD
and stored for lexical types and subroutine return types.
.PP
\fIDynaLoader 2.00c and XSLoader as builtins\fR
.IX Subsection "DynaLoader 2.00c and XSLoader as builtins"
.PP
Starting with cperl (based on Perl 5.22) DynaLoader and XSLoader have
no perl code anymore, \fIDynaLoader.pm\fR was rewritten as \fIdlboot.c\fR.
.PP
\&\fBChanges\fR:
.PP
\&\f(CW@dl_library_path\fR eliminates now all duplicate paths and resolves symlinks of
\&\f(CW$Config{libpth}\fR at build time.
.PP
Only the \f(CW$ENV{PERL_BUILD_EXPAND_CONFIG_VARS}\fR settings are
implemented. All Config settings are compiled in at build time, run-time
changes are not honored. Config is now also a compiled module,
\&\fIConfig_heavy.pl\fR is gone, and its hash was always readonly, so there's no
way to change Config values at run-time without recompiling it.
.PP
Not sure yet about keeping support for \fI.bs\fR hooks and \f(CW@dl_resolve_using\fR.
.PP
The \f(CW\*(C`XSLoader::load_file($module, $modlibname, ...)\*(C'\fR function is new,
XSLoader is a builtin also. \f(CW\*(C`...\*(C'\fR is passed to the loaded \s-1XS\s0 function
as with \f(CW\*(C`XSLoader::load($module, ...)\*(C'\fR.
.PP
\fIConfig as \s-1XS\s0 extension\fR
.IX Subsection "Config as XS extension"
.PP
It is compiled as shared library, with all keys as readonly perfect
hash.  Some internal variables are not accessible anymore, the \s-1API\s0 is
via the documented functions. See our Mock::Config module if you need
to change a Config value for tests.
.PP
\fIwarnings as \s-1XS\s0 extension (\s-1NY\s0)\fR
.IX Subsection "warnings as XS extension (NY)"
.PP
It is compiled as shared library, the builtin categories are
implemented as perfect hash, and extended with a normal perl hash.
Some internal variables are not accessible anymore, the \s-1API\s0 is via the
documented functions.
.PP
\&\fBStatus:\fR 1 scope bug with Carp. Not yet enabled.
.SS "Added the compiler back to core"
.IX Subsection "Added the compiler back to core"
The B::C <http://search.cpan.org/dist/B-C/> testsuite runs too long
for cpan users, and it needs to be developed in sync to avoid typical
6 months wait-time after a core change.  Maybe provide python-like
precompiled \f(CW\*(C`ByteCache\*(C'\fR \fI.pmc\fR as default. You could pre-compile
then modules with higher optimization levels, esp. the type
inferencer.
.PP
Maybe include a \f(CW\*(C`Data::Compile\*(C'\fR module to dump only data without all
the code to a shared library, and possibly
Perfect::Hash <https://github.com/rurban/Perfect-Hash> and a new
\&\fIph.c\fR to create and optimize readonly hashes, which is needed for
the shared \s-1XS\s0 hashes of Config, warnings and unicode tables.
.SS "Backport core testsuite fixes for the compiler"
.IX Subsection "Backport core testsuite fixes for the compiler"
Honor differences between compile-time und run-time, when run
compiled.  Other than a few wrong testcases, the compilers does pass
the core testsuite.
.PP
See <https://github.com/perl11/p5\-coretests> for a generally improved
testsuite for perl5, cperl and B::C.
.SH "Plans for further core features"
.IX Header "Plans for further core features"
.SS "Lexical methods"
.IX Subsection "Lexical methods"
Lexical methods are of course \fBprivate\fR to its enclosing class,
i.e. not visable from outside the class. And they are also \fBclosed\fR
(or also called \fIsealed\fR or \fIfinal\fR) as planned by Damian Conway,
i.e. they cannot be changed later. This enables the compiler to inline
them automatically when its worthwhile. e.g. when they are small
enough.  They are either defined in the new style: \f(CW\*(C`class .. { my
method .. }\*(C'\fR or old style: \f(CW\*(C`package .. { my sub .. }\*(C'\fR
.PP
\fICarp 2.00c as builtin\fR
.IX Subsection "Carp 2.00c as builtin"
.PP
Carp might be a implemented as builtin \s-1XS\s0 module.  There's no need
to require it.  \fICarp.pm\fR is only provided for documentation,
\&\f(CW\*(C`$INC{\*(AqCarp.pm\*(Aq} = \*(Aqxsutils.c\*(Aq\*(C'\fR
Many carp function are added to the perl5 \s-1API\s0 and available to core
and extensions.
.PP
\&\fBChanges\fR:
.PP
Currently shortmess is only simplified, the step to skip packages which
trust each other (via \f(CW@CARP_NOT\fR or \f(CW@ISA\fR) is not yet implemented,
neither is the \f(CW\*(C`CARP_TRACE\*(C'\fR formatting hook.  The deprecated
\&\f(CW$Carp::CarpLevel\fR variable is now ignored.
.PP
Other not yet implemented variables: \f(CW$Carp::MaxEvalLen\fR,
\&\f(CW$Carp::MaxArgLen\fR, \f(CW$Carp::MaxArgNums\fR, \f(CW$Carp::RefArgFormatter\fR
.PP
\&\fBNote\fR:
.PP
This branch is currently not included. It's too instable to get the
caller depth right from pure perl vs \s-1XS,\s0 and most extended hooks
(format, \s-1CARP_TRACE, CARP_NOT\s0) are not yet implemented.
Note that \s-1XS\s0 calls usually do not get counted in caller, unless you
use the \s-1SCOPE\s0 keyword.
.PP
\fIunicode folding tables as \s-1XS\s0 extension\fR
.IX Subsection "unicode folding tables as XS extension"
.PP
They are compiled as shared library, with all keys as readonly perfect
hash.  Some internal variables are not accessible anymore, the \s-1API\s0 is
via the documented functions.
.PP
Maybe seperate them into a light folding table and heavy names and
properties.
.SS "Remove Attribute::Handler from core"
.IX Subsection "Remove Attribute::Handler from core"
This evals all attributes at compile-time. Discourage its usage.
.SH "Longer term goals"
.IX Header "Longer term goals"
.SS "Faster functions calls"
.IX Subsection "Faster functions calls"
Optionally omit caller, \f(CW@_\fR, freetmps, exception handler when possible,
i.e.  no string eval's are present in the body, the compiler can
detect it or the right compiler hint is given.
.SS "tailcall optimization"
.IX Subsection "tailcall optimization"
Detect tail positions and replace the call with a fast goto. This
needs to be in core, not as external module. Without tailcall
elimination handling longer lists leads to stack exhaustion. python
did the same mistake as p5p by enforcing a new context for every goto.
goto to signatures are now real fast tailcalls.
.SS "Proper object system"
.IX Subsection "Proper object system"
No, not Moose, but close.  Rather an optimizable perl6\-like object
system in core.  Provide a simple \s-1MOP\s0 for reflection purposes, bot not
for overrides, i.e. metaobjects for classes, proper class and method
syntax, anonymous classes by pointer not name, proper multi dispatch
with types, roles, class and method lookup by pointer, not by name.
Create native optimized shapes via mixins as in p2 (an enhanced
bless). Lexical methods are private, optimize dispatch for single
inheritance. i.e the convenient class syntax extends on a single class
only, classes are finalizable by the calling application.
.PP
Support multi-dispatch in perl6 syntax and optimize for early-bound
method calls with typed arguments and closed classes.
.PP
Dispatch is via C3, not the old depth-first left-to-right mro
implementation.
.PP
For type inference we will need to make \f(CW\*(C`new\*(C'\fR a special keyword,
which is a shortcut for \f(CW\*(C`bless\*(C'\fR, with a fixed classname. \f(CW\*(C`bless\*(C'\fR can
use computed classnames and thus enforces dynamic types.
.SS "libffi in core"
.IX Subsection "libffi in core"
Declare extern functions and libraries and call them. There's no need
for \s-1XS\s0 and seperate compilation for most bindings. Not everybody has a
compiler, the very same compiler perl was compiled with.
libffi is the slowest ffi library, but has the best platform support, as it is
integrated with gcc for java jni support.
.PP
.Vb 3
\&   extern sub atoi(str $s):int;
\&   extern sub itoa(int $s):str;
\&   extern sub printf(str $s, ...):void;
.Ve
.PP
Note that this deviates from perl6 synatx with \f(CW\*(C`is native\*(C'\fR, but perl6
uses the \f(CW\*(C`is\*(C'\fR traits for all function attributes, which we do not.
.SS "Editor integration"
.IX Subsection "Editor integration"
With type inference we can provide a much nicer development
environment, which also supports the debugger.  \fBplsense\fR should give
type feedback.  I'm thinking of a port of \fBZeroBrane Studio\fR for
perl. This means provide core support for the needed serializers and
introspection facilities.
.SS "Jit"
.IX Subsection "Jit"
Add a jit for the easiest platforms, and provide dynamic
javascript-based optimizations when stacks need to be replaced.
Eventually even promote to bignum not double automatically, as in
perl6. But this is optional, the next points are more important.
Jit's are a bit overrated. a fast bytecode loop can easily beat a jit
and optimizing compiler, see luajit2,
<http://www.emulators.com/docs/nx25_nostradamus.htm> or
<http://nominolo.blogspot.de/2012/07/implementing\-fast\-interpreters.html>
.PP
A tracing jit, and not a method jit sounds best, together with the inliner,
native op sequences and loop optimizations.
.SS "Optimize the vm, the runloop"
.IX Subsection "Optimize the vm, the runloop"
We carry around way too much bloat in the ops and the data, which is
not needed at run-time. e.g. the compiler throws away the nested
symbol table stashes if not needed, which frees 20% memory.
But think of a lua/p2\-like redesign of tagged values and slimmer ops,
and eventually put the stack onto the \s-1CPU\s0 stack.
.PP
Note that p5p argues the opposite way. They want to add even more
run-time branches to the ops, without any justification.
.PP
Optimize special arithmetic op sequences to use unboxed integers and
strings on the stack.  We experiment in allowing unboxed values on the
stack, because the stack is not garbage collected and not refcounted.
We just need to be sure to box them before entering a
non-collaborating sub, leaving a block with possible exceptions and
stack cleanup. Those unboxed values are internally typed as \f(CW\*(C`:int\*(C'\fR
and \f(CW\*(C`:str\*(C'\fR.  Note that the coretypes \f(CW\*(C`:int\*(C'\fR and \f(CW\*(C`:str\*(C'\fR are not
guaranteed to be unboxed, only if the compiler sees fit. In most cases
those values are boxed but without a class pointer and magic attached.
(Done in the native branch)
.PP
Maybe rewrite to a better register-based compiler with fixed-length 2
operands as in p2, but this might be too tricky for \s-1XS,\s0 mapping the
global stack to the local stack.  Probably no \s-1SSA\s0 (three arguments),
just a cpu friendly two argument form as in p2/lua 5.1.
.PP
Allow faster \s-1XS\s0 calls, user-provided function calls and method calls.
Provide support for named arguments in the vm, fast not via hashes.
Many of the current io+sys ops are better implemented as library
methods.  With ~50ops instead of >300 the runloop might fit into the
L1 cache again.  Seperate calling of fixed arity methods from varargs.
detect and use tailcalls automatically.  Do not step into a seperate
runloop for every single function call, only for coros, which do need
to record the the stack information.
.PP
Run-time optimize the data, no 2x indirection to access hash and array
structs.
Provide forwarding pointers to single tuples to hold all.
This could provide also the possibility for a \s-1GC\s0 if a second sweep
for timely destruction is doable.
.PP
Optimize \fB\s-1HEK\s0\fR for faster hash comparison, and use it for native str
types, which might benefit from its immutability and the pre-calculated
hash, len and utf8 fields.
.PP
Check readonly support for \f(CW\*(C`PL_strtab\*(C'\fR for the compiler.
Builtin ro ph + dynamic as in warnings \s-1XS.\s0
.SS "Better symbol table"
.IX Subsection "Better symbol table"
Check converting the \s-1GV\s0 stash tree of hashes into a single global data
structure, not a nested hash of hashes: Hash, \s-1AVL\s0 tree, Trie (\s-1TST\s0 or
\&\s-1RX TST\s0), Patricia trie or \s-1DAFSA\s0 (Deterministic acyclic finite state
automaton) for faster dynamic variable and function name lookup. No
binary names, all as \s-1UTF8.\s0 Maybe restrict to \s-1ASCII\s0 or valid
identifiers to limit the trie memory (array of 26 vs 256).  Stashes
point then to trie nodes and need a \s-1HV\s0 check.  Optionally provide
partial read-only support for the compiler, as for \f(CW\*(C`PL_strtab\*(C'\fR.
.SS "Coro support"
.IX Subsection "Coro support"
Keep native threads asis (this is not fixable, better remove it), but
actively help coroutine and async \s-1IO\s0 support.
.SS "Untangle the \s-1IO\s0 layer mess"
.IX Subsection "Untangle the IO layer mess"
A stack is a stack.
.SS "Bring back proper `match` and `given/when`"
.IX Subsection "Bring back proper `match` and `given/when`"
With type support it would be even efficient and helps the inferencer.
\&\f(CW\*(C`match\*(C'\fR needs to be structural, p5p \f(CW\*(C`smartmatch\*(C'\fR can stay dumb as it is now.
.SS "clp"
.IX Subsection "clp"
Possibly add a \fBclp\fR library, a constraint logic solver, with possible
bindings to external sat solvers, like minisat, which can be included
due to its small size and license.  It is solved by checking for lvalue
function calls in assignments, when the function is not declared as
\&\f(CW\*(C`:lvalue\*(C'\fR.
.PP
.Vb 5
\&    use clp;
\&    sub fact(int $i=0) :int { assert $i>=0; return $i ? fact($i\-1) : 1 }
\&    say fact(7);     # => 5040
\&    fact($_) = 5040; # solve it!
\&    say $_;          # => 7
.Ve
.PP
The type optimizer with advanced types might eventually benefit from
its native performance.
.SH "Development policies"
.IX Header "Development policies"
We favor community-friendly democratic development policies as e.g. in
perl6 over the usual old-style dictatorial model.  That means the
powerful (those with management and commit roles) are not allowed to
abuse their powers, while the powerless users are allowed and need to
have the abilities to criticise them and their code.
.PP
In the old trust-based dictatorial model as e.g. in linux or perl5 the
powerful call the not powerful abusive names (\*(L"asshole\*(R" or \*(L"jerk\*(R" is
very common, or \*(L"trolls\*(R"), and are allowed to avoid discussions
of features or problems by directly committing to master, rejecting
tickets or selectively abuse their powers. This is forbidden in cperl.
.PP
We track stable upstream releases for our releases only. The current
stable release is based in 5.23.0, which will lead to 5.22.1. The
previous stable release was 5.14.4, as 5.16 introduced critical
instabilities which were not fixed mostly until 5.20 and 5.22, and
5.20 alone was not worth to update cperl to. The previous stable
release was 5.8.9 and the one before was 5.6.2.  So we do not know
which will be the next stable cperl release. It could be 5.24, but
usually it takes longer, so something like 5.30 sounds realistic.  So
far we have detected 2 grave \s-1API\s0 mistakes in 5.22.0. But we do merge
all official p5p releases into our development branch monthly.
.SH "With classes, types, compilable, company friendly"
.IX Header "With classes, types, compilable, company friendly"
.IP "\fBclasses (not yet)\fR" 4
.IX Item "classes (not yet)"
A true perl6\-like and efficient object system is in work, but not yet
enabled.  It supports the perl6\-like syntax for class, method, has,
roles (mixins, compile-time composable classes), method modifiers
(:before, :after, :around), multiple type dispatch (multi, no need to
overload methods), finalizable classes (compile-time optimizations)
and easier perl6\-like syntax, which closely resembles early perl6
designs, Damian Conway's perl5i and \f(CW\*(C`Moose\*(C'\fR without its massive
overhead.
.Sp
There's no \fB\s-1MOP\s0\fR (meta-object protocol), but reflection. There's no need
to override the internal behavior of the object system, the dispatch,
the class and role layout.
.Sp
See perlclass (\s-1NY\s0)
.IP "\fBtypes\fR" 4
.IX Item "types"
cperl includes builtin coretypes, and later native types, user-defined
types and type dispatch, checks, subtype relationships, inference and
optimizations on user-defined functions and methods, for \s-1XS\s0 and \s-1PP.\s0
.Sp
See perltypes
.IP "\fBcompilable\fR" 4
.IX Item "compilable"
perl5 proper started being compiler unfriendly with 5.16, with changed
security and string handling. It can be compiled but it is not
recommended, as it features only about 5% memory savings. B::C can
still strip the nested stashes (namespaces), but needs to keep all \s-1COW\s0
strings dynamic.
.Sp
With cperl we can again compile to more efficient code, with > 35%
memory savings.
.Sp
See B::C <http://search.cpan.org/dist/B-C/>
.IP "\fBcompany friendly\fR" 4
.IX Item "company friendly"
The optional types lead to better documentation, earlier compile-time
type violations, less needed tests and more performance. Managers love
this.
.Sp
It is also better compilable.
.SH "How to detect cperl?"
.IX Header "How to detect cperl?"
.IP "\fIconfig.h\fR defines <\s-1USE_CPERL\s0>" 4
.IX Item "config.h defines <USE_CPERL>"
.PD 0
.ie n .IP "\fIConfig.pm\fR defines ""usecperl""" 4
.el .IP "\fIConfig.pm\fR defines \f(CWusecperl\fR" 4
.IX Item "Config.pm defines usecperl"
.ie n .IP "cperl changed modules end with ""c"", typically ""_01c""." 4
.el .IP "cperl changed modules end with \f(CWc\fR, typically \f(CW_01c\fR." 4
.IX Item "cperl changed modules end with c, typically _01c."
.IP "Libraries are installed into \fI/usr/local/lib/cperl\fR, not \fI/usr/local/lib/perl5\fR." 4
.IX Item "Libraries are installed into /usr/local/lib/cperl, not /usr/local/lib/perl5."
.PD
.SH "Type links"
.IX Header "Type links"
Most dynamic languages are currently in the process to get type
support.  This happened for perl5 at around 2002, but was never
properly led (the developers had to leave p5p) and was then destroyed
with 5.10, and then actively blocked for decades.
.IP "<http://www.typescriptlang.org/Content/TypeScript%20Language%20Specification.pdf>  (microsoft's javascript with types)" 4
.IX Item "<http://www.typescriptlang.org/Content/TypeScript%20Language%20Specification.pdf> (microsoft's javascript with types)"
.PD 0
.IP "<https://code.facebook.com/posts/1505962329687926/flow\-a\-new\-static\-type\-checker\-for\-javascript/> (facebook's javascript with types)" 4
.IX Item "<https://code.facebook.com/posts/1505962329687926/flow-a-new-static-type-checker-for-javascript/> (facebook's javascript with types)"
.IP "<https://github.com/rwaldron/tc39\-notes/blob/master/es6/2015\-01/JSExperimentalDirections.pdf> Soundscript, google's javascript with types" 4
.IX Item "<https://github.com/rwaldron/tc39-notes/blob/master/es6/2015-01/JSExperimentalDirections.pdf> Soundscript, google's javascript with types"
.IP "<https://www.python.org/dev/peps/pep\-0484/>  (planned python with types)" 4
.IX Item "<https://www.python.org/dev/peps/pep-0484/> (planned python with types)"
.IP "<http://www.mypy\-lang.org/> (existing python with types)" 4
.IX Item "<http://www.mypy-lang.org/> (existing python with types)"
.IP "<https://news.ycombinator.com/item?id=8620129> (ruby 3.0 planned with types)" 4
.IX Item "<https://news.ycombinator.com/item?id=8620129> (ruby 3.0 planned with types)"
.IP "<http://crystal\-lang.org/> (a good existing ruby with types)" 4
.IX Item "<http://crystal-lang.org/> (a good existing ruby with types)"
.IP "<http://hacklang.org/> (facebook's php with types)" 4
.IX Item "<http://hacklang.org/> (facebook's php with types)"
.IP "<http://blog.pascal\-martin.fr/post/in\-favor\-of\-rfc\-scalar\-type\-hints.html> (php 7 types overview)" 4
.IX Item "<http://blog.pascal-martin.fr/post/in-favor-of-rfc-scalar-type-hints.html> (php 7 types overview)"
.IP "<https://wiki.php.net/rfc/scalar_type_hints> (php 7)" 4
.IX Item "<https://wiki.php.net/rfc/scalar_type_hints> (php 7)"
.IP "<https://wiki.php.net/rfc/return_types> (php 7)" 4
.IX Item "<https://wiki.php.net/rfc/return_types> (php 7)"
.IP "<http://frenchy64.github.io/2015/06/19/gradual\-typing.html>" 4
.IX Item "<http://frenchy64.github.io/2015/06/19/gradual-typing.html>"
.IP "<http://blogs.perl.org/users/rurban/2012/09/my\-perl5\-todo\-list.html> (the old plan, ignored)" 4
.IX Item "<http://blogs.perl.org/users/rurban/2012/09/my-perl5-todo-list.html> (the old plan, ignored)"
.IP "<http://perl11.org/cperl/>" 4
.IX Item "<http://perl11.org/cperl/>"
